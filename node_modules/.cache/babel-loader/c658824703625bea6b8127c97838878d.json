{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FountainEncoderPart = void 0;\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst fountainUtils_1 = require(\"./fountainUtils\");\n\nconst cbor_1 = require(\"./cbor\");\n\nclass FountainEncoderPart {\n  constructor(_seqNum, _seqLength, _messageLength, _checksum, _fragment) {\n    this._seqNum = _seqNum;\n    this._seqLength = _seqLength;\n    this._messageLength = _messageLength;\n    this._checksum = _checksum;\n    this._fragment = _fragment;\n  }\n\n  get messageLength() {\n    return this._messageLength;\n  }\n\n  get fragment() {\n    return this._fragment;\n  }\n\n  get seqNum() {\n    return this._seqNum;\n  }\n\n  get seqLength() {\n    return this._seqLength;\n  }\n\n  get checksum() {\n    return this._checksum;\n  }\n\n  cbor() {\n    const result = cbor_1.cborEncode([this._seqNum, this._seqLength, this._messageLength, this._checksum, this._fragment]);\n    return Buffer.from(result);\n  }\n\n  description() {\n    return `seqNum:${this._seqNum}, seqLen:${this._seqLength}, messageLen:${this._messageLength}, checksum:${this._checksum}, data:${this._fragment.toString('hex')}`;\n  }\n\n  static fromCBOR(cborPayload) {\n    const [seqNum, seqLength, messageLength, checksum, fragment] = cbor_1.cborDecode(cborPayload);\n    assert_1.default(typeof seqNum === 'number');\n    assert_1.default(typeof seqLength === 'number');\n    assert_1.default(typeof messageLength === 'number');\n    assert_1.default(typeof checksum === 'number');\n    assert_1.default(Buffer.isBuffer(fragment) && fragment.length > 0);\n    return new FountainEncoderPart(seqNum, seqLength, messageLength, checksum, Buffer.from(fragment));\n  }\n\n}\n\nexports.FountainEncoderPart = FountainEncoderPart;\n\nclass FountainEncoder {\n  constructor(message) {\n    let maxFragmentLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    let firstSeqNum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let minFragmentLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;\n    const fragmentLength = FountainEncoder.findNominalFragmentLength(message.length, minFragmentLength, maxFragmentLength);\n    this._messageLength = message.length;\n    this._fragments = FountainEncoder.partitionMessage(message, fragmentLength);\n    this.fragmentLength = fragmentLength;\n    this.seqNum = utils_1.toUint32(firstSeqNum);\n    this.checksum = utils_1.getCRC(message);\n  }\n\n  get fragmentsLength() {\n    return this._fragments.length;\n  }\n\n  get fragments() {\n    return this._fragments;\n  }\n\n  get messageLength() {\n    return this._messageLength;\n  }\n\n  isComplete() {\n    return this.seqNum >= this._fragments.length;\n  }\n\n  isSinglePart() {\n    return this._fragments.length === 1;\n  }\n\n  seqLength() {\n    return this._fragments.length;\n  }\n\n  mix(indexes) {\n    return indexes.reduce((result, index) => utils_1.bufferXOR(this._fragments[index], result), Buffer.alloc(this.fragmentLength, 0));\n  }\n\n  nextPart() {\n    this.seqNum = utils_1.toUint32(this.seqNum + 1);\n    const indexes = fountainUtils_1.chooseFragments(this.seqNum, this._fragments.length, this.checksum);\n    const mixed = this.mix(indexes);\n    return new FountainEncoderPart(this.seqNum, this._fragments.length, this._messageLength, this.checksum, mixed);\n  }\n\n  static findNominalFragmentLength(messageLength, minFragmentLength, maxFragmentLength) {\n    assert_1.default(messageLength > 0);\n    assert_1.default(minFragmentLength > 0);\n    assert_1.default(maxFragmentLength >= minFragmentLength);\n    const maxFragmentCount = Math.ceil(messageLength / minFragmentLength);\n    let fragmentLength = 0;\n\n    for (let fragmentCount = 1; fragmentCount <= maxFragmentCount; fragmentCount++) {\n      fragmentLength = Math.ceil(messageLength / fragmentCount);\n\n      if (fragmentLength <= maxFragmentLength) {\n        break;\n      }\n    }\n\n    return fragmentLength;\n  }\n\n  static partitionMessage(message, fragmentLength) {\n    let remaining = Buffer.from(message);\n    let fragment;\n    let _fragments = [];\n\n    while (remaining.length > 0) {\n      [fragment, remaining] = utils_1.split(remaining, -fragmentLength);\n      fragment = Buffer.alloc(fragmentLength, 0) // initialize with 0's to achieve the padding\n      .fill(fragment, 0, fragment.length);\n\n      _fragments.push(fragment);\n    }\n\n    return _fragments;\n  }\n\n}\n\nexports.default = FountainEncoder; //# sourceMappingURL=fountainEncoder.js.map","map":null,"metadata":{},"sourceType":"script"}