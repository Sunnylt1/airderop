{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst fountainDecoder_1 = __importDefault(require(\"./fountainDecoder\"));\n\nconst bytewords_1 = __importDefault(require(\"./bytewords\"));\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst errors_1 = require(\"./errors\");\n\nconst ur_1 = __importDefault(require(\"./ur\"));\n\nconst fountainEncoder_1 = require(\"./fountainEncoder\");\n\nclass URDecoder {\n  constructor() {\n    let fountainDecoder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new fountainDecoder_1.default();\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bytes';\n    this.fountainDecoder = fountainDecoder;\n    this.type = type;\n    assert_1.default(utils_1.isURType(type), 'Invalid UR type');\n    this.expected_type = '';\n  }\n\n  static decodeBody(type, message) {\n    const cbor = bytewords_1.default.decode(message, bytewords_1.default.STYLES.MINIMAL);\n    return new ur_1.default(Buffer.from(cbor, 'hex'), type);\n  }\n\n  validatePart(type) {\n    if (this.expected_type) {\n      return this.expected_type === type;\n    }\n\n    if (!utils_1.isURType(type)) {\n      return false;\n    }\n\n    this.expected_type = type;\n    return true;\n  }\n\n  static decode(message) {\n    const [type, components] = this.parse(message);\n\n    if (components.length === 0) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n\n    const body = components[0];\n    return URDecoder.decodeBody(type, body);\n  }\n\n  static parse(message) {\n    const lowercase = message.toLowerCase();\n    const prefix = lowercase.slice(0, 3);\n\n    if (prefix !== 'ur:') {\n      throw new errors_1.InvalidSchemeError();\n    }\n\n    const components = lowercase.slice(3).split('/');\n    const type = components[0];\n\n    if (components.length < 2) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n\n    if (!utils_1.isURType(type)) {\n      throw new errors_1.InvalidTypeError();\n    }\n\n    return [type, components.slice(1)];\n  }\n\n  static parseSequenceComponent(s) {\n    const components = s.split('-');\n\n    if (components.length !== 2) {\n      throw new errors_1.InvalidSequenceComponentError();\n    }\n\n    const seqNum = utils_1.toUint32(Number(components[0]));\n    const seqLength = Number(components[1]);\n\n    if (seqNum < 1 || seqLength < 1) {\n      throw new errors_1.InvalidSequenceComponentError();\n    }\n\n    return [seqNum, seqLength];\n  }\n\n  receivePart(s) {\n    if (this.result !== undefined) {\n      return false;\n    }\n\n    const [type, components] = URDecoder.parse(s);\n\n    if (!this.validatePart(type)) {\n      return false;\n    } // If this is a single-part UR then we're done\n\n\n    if (components.length === 1) {\n      this.result = URDecoder.decodeBody(type, components[0]);\n      return true;\n    }\n\n    if (components.length !== 2) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n\n    const [seq, fragment] = components;\n    const [seqNum, seqLength] = URDecoder.parseSequenceComponent(seq);\n    const cbor = bytewords_1.default.decode(fragment, bytewords_1.default.STYLES.MINIMAL);\n    const part = fountainEncoder_1.FountainEncoderPart.fromCBOR(cbor);\n\n    if (seqNum !== part.seqNum || seqLength !== part.seqLength) {\n      return false;\n    }\n\n    if (!this.fountainDecoder.receivePart(part)) {\n      return false;\n    }\n\n    if (this.fountainDecoder.isSuccess()) {\n      this.result = new ur_1.default(this.fountainDecoder.resultMessage(), type);\n    } else if (this.fountainDecoder.isFailure()) {\n      this.error = new errors_1.InvalidSchemeError();\n    }\n\n    return true;\n  }\n\n  resultUR() {\n    return this.result ? this.result : new ur_1.default(Buffer.from([]));\n  }\n\n  isComplete() {\n    return this.result && this.result.cbor.length > 0;\n  }\n\n  isSuccess() {\n    return !this.error && this.isComplete();\n  }\n\n  isError() {\n    return this.error !== undefined;\n  }\n\n  resultError() {\n    return this.error ? this.error.message : '';\n  }\n\n  expectedPartCount() {\n    return this.fountainDecoder.expectedPartCount();\n  }\n\n  expectedPartIndexes() {\n    return this.fountainDecoder.getExpectedPartIndexes();\n  }\n\n  receivedPartIndexes() {\n    return this.fountainDecoder.getReceivedPartIndexes();\n  }\n\n  lastPartIndexes() {\n    return this.fountainDecoder.getLastPartIndexes();\n  }\n\n  estimatedPercentComplete() {\n    return this.fountainDecoder.estimatedPercentComplete();\n  }\n\n  getProgress() {\n    return this.fountainDecoder.getProgress();\n  }\n\n}\n\nexports.default = URDecoder; //# sourceMappingURL=urDecoder.js.map","map":null,"metadata":{},"sourceType":"script"}