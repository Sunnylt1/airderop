{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SolanaWallet = void 0;\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nconst bs58_1 = __importDefault(require(\"bs58\"));\n\nconst buffer_1 = require(\"buffer\");\n\nclass SolanaWallet {\n  constructor(auth, rpcUrl) {\n    this.auth = auth;\n    this.rpcUrl = rpcUrl;\n    this.isParticleNetwork = true;\n    this.auth = auth;\n    this.rpcUrl = rpcUrl;\n    this._connecting = false;\n    const userInfo = this.auth.userInfo();\n\n    if (userInfo) {\n      const wallet = userInfo.wallets.find(w => w.chain_name === \"solana\" && w.public_address.length > 0);\n\n      if (wallet) {\n        this._publicKey = new web3_js_1.PublicKey(wallet.public_address);\n      } else {\n        this._publicKey = null;\n      }\n    } else {\n      this._publicKey = null;\n    }\n\n    this.auth.on(\"connect\", userInfo => {\n      const wallet = userInfo.wallets.find(w => w.chain_name === \"solana\" && w.public_address.length > 0);\n\n      if (wallet) {\n        this._publicKey = new web3_js_1.PublicKey(wallet.public_address);\n      }\n    });\n    this.auth.on(\"disconnect\", () => {\n      this._publicKey = null;\n    });\n  }\n\n  get connecting() {\n    return this._connecting;\n  }\n\n  get connected() {\n    return this._publicKey !== null;\n  }\n\n  get publicKey() {\n    return this._publicKey;\n  }\n\n  connect(config) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this._connecting = true;\n        let wallet = this.auth.wallet();\n\n        if (wallet) {\n          this._publicKey = new web3_js_1.PublicKey(wallet.public_address);\n          return Promise.resolve();\n        }\n\n        yield this.auth.login(config);\n        wallet = this.auth.wallet();\n\n        if (wallet) {\n          this._publicKey = new web3_js_1.PublicKey(wallet.public_address);\n          return Promise.resolve();\n        } else {\n          return Promise.reject(\"wallet create failed\");\n        }\n      } catch (e) {\n        return Promise.reject(e);\n      } finally {\n        this._connecting = false;\n      }\n    });\n  }\n\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.auth.logout();\n      this._publicKey = null;\n      return Promise.resolve();\n    });\n  }\n\n  signTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const signature = yield this.auth.sign(\"signTransaction\", bs58_1.default.encode(transaction.serialize({\n        requireAllSignatures: false,\n        verifySignatures: false\n      })));\n      return web3_js_1.Transaction.from(buffer_1.Buffer.from(signature, \"base64\"));\n    });\n  }\n\n  signAllTransactions(transactions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const signatures = yield this.auth.signAllTransactions(transactions.map(tx => bs58_1.default.encode(tx.serialize({\n        requireAllSignatures: false,\n        verifySignatures: false\n      }))));\n      return signatures.map(signed => web3_js_1.Transaction.from(buffer_1.Buffer.from(signed, \"base64\")));\n    });\n  }\n\n  signAndSendTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.auth.sendTransaction(bs58_1.default.encode(transaction.serialize({\n        requireAllSignatures: false,\n        verifySignatures: false\n      })));\n    });\n  }\n\n  signMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const signature = yield this.auth.sign(\"signMessage\", bs58_1.default.encode(message));\n      return buffer_1.Buffer.from(signature, \"base64\");\n    });\n  }\n\n  getConnection(config) {\n    const url = this.rpcUrl ? this.rpcUrl + \"/solana/rpc\" : \"https://api.particle.network/solana-chain/rpc\";\n    return new web3_js_1.Connection(`${url}?chainId=${this.auth.chainId()}`, {\n      commitment: config === null || config === void 0 ? void 0 : config.commitment,\n      wsEndpoint: config === null || config === void 0 ? void 0 : config.wsEndpoint,\n      httpHeaders: {\n        Authorization: this.auth.basicCredentials()\n      },\n      fetch: config === null || config === void 0 ? void 0 : config.fetch,\n      fetchMiddleware: config === null || config === void 0 ? void 0 : config.fetchMiddleware,\n      disableRetryOnRateLimit: config === null || config === void 0 ? void 0 : config.disableRetryOnRateLimit,\n      confirmTransactionInitialTimeout: config === null || config === void 0 ? void 0 : config.confirmTransactionInitialTimeout\n    });\n  }\n\n}\n\nexports.SolanaWallet = SolanaWallet; //# sourceMappingURL=solana-wallet.js.map","map":null,"metadata":{},"sourceType":"script"}