{"ast":null,"code":"import { Message, PublicKey, SIGNATURE_LENGTH_IN_BYTES, Transaction } from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { EventEmitter } from \"eventemitter3\";\nconst DEFAULT_SIGNATURE_BUFFER = Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);\nexport class StrikeWallet extends EventEmitter {\n  constructor() {\n    super();\n    this.url = 'https://wallet.strikeprotocols.com';\n\n    this.cleanUp = () => {\n      [...this._timers].forEach(t => this.clearTimer(t));\n      const wallet = this._wallet;\n\n      if (wallet) {\n        wallet.close();\n      }\n\n      this._wallet = null;\n      this.emit('disconnected');\n    };\n\n    this.clearTimer = timer => {\n      this._timers = this._timers.filter(t => t != timer);\n      window.clearInterval(timer);\n    };\n\n    this.instructionsToSerializableInstructions = instructions => instructions.map(i => {\n      return {\n        'programId': i.programId.toBase58(),\n        'accountMetas': i.keys.map(k => {\n          return {\n            address: k.pubkey.toBase58(),\n            signer: k.isSigner,\n            writable: k.isWritable\n          };\n        }),\n        'data': window.btoa(String.fromCharCode(...i.data))\n      };\n    });\n\n    this.handleWalletMessage = data => {\n      var _a, _b, _c;\n\n      if (data.type == \"connected\") {\n        this._connecting = false;\n\n        if (!data.error) {\n          this.isLoggedIn = true;\n\n          if ((_a = data.connected) === null || _a === void 0 ? void 0 : _a.publicKey) {\n            this._publicKey = new PublicKey(data.connected.publicKey);\n          }\n        }\n      } else if ([\"sendTransaction\", \"sendFinalTransaction\"].includes(data.type)) {\n        const transactionIdentifier = (_b = data.sendTransaction) === null || _b === void 0 ? void 0 : _b.identifier;\n\n        if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n          if (data.error) {\n            this._pendingTransactionErrors[transactionIdentifier] = {\n              message: data.error\n            };\n          } else {\n            this._pendingTransactions[transactionIdentifier] = data.sendTransaction || null;\n          }\n        }\n      } else if (data.type == \"signTransaction\") {\n        const transactionIdentifier = (_c = data.signTransaction) === null || _c === void 0 ? void 0 : _c.identifier;\n\n        if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n          if (data.error) {\n            this._pendingTransactionErrors[transactionIdentifier] = {\n              message: data.error\n            };\n          } else {\n            this._pendingTransactions[transactionIdentifier] = data.signTransaction || null;\n          }\n        }\n      }\n    };\n\n    this.isLoggedIn = false;\n    this._pendingTransactions = {};\n    this._pendingTransactionErrors = {};\n    this._timers = [];\n    this._wallet = null;\n    this._connecting = false;\n    this._publicKey = null;\n    window.addEventListener(\"message\", e => {\n      this.handleWalletMessage(e.data);\n    });\n  }\n\n  async connect(url) {\n    try {\n      this.url = url || this.url;\n      const origin = encodeURIComponent(window.location.origin);\n      const connectUrl = `${this.url}/connect?origin=${origin}`;\n      this._connecting = true;\n      this._wallet = window.open(connectUrl, `strike-wallet-${origin}`, \"height=900,width=800,menubar=no,status=no,toolbar=no\");\n\n      if (!this._wallet) {\n        this._connecting = false;\n        throw new Error(\"Unable to connect to wallet\");\n      }\n\n      this._timers.push(window.setInterval(() => {\n        if (this._wallet.closed) {\n          this.cleanUp();\n        } else if (this._wallet) {\n          this._wallet.postMessage({\n            type: 'heartbeat'\n          }, this.url);\n        }\n      }, 100));\n\n      return new Promise((resolve, reject) => {\n        const timer = window.setInterval(() => {\n          if (this.isLoggedIn && this._publicKey) {\n            this.clearTimer(timer);\n            resolve(this._publicKey);\n          } else if (!this.isLoggedIn && !this._connecting) {\n            this.clearTimer(timer);\n            reject(new Error(\"Unable to connect to Strike\"));\n          }\n        }, 100);\n\n        this._timers.push(timer);\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async signTransaction(transaction) {\n    this.verifyCanSignRequests([transaction]);\n\n    try {\n      return this.signOneTransaction(transaction);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async signAllTransactions(transactions) {\n    this.verifyCanSignRequests(transactions);\n\n    try {\n      return this.signMultipleTransactions(transactions);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async sendTransaction(transaction, connection, options) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new Error(\"Not Connected\");\n      const transactionIdentifier = uuidv4();\n      this._pendingTransactions[transactionIdentifier] = null;\n      const signers = options ? options.signers : undefined;\n\n      if (signers && signers.length > 0) {\n        return new Promise((resolve, reject) => {\n          this.signOneTransaction(transaction, transactionIdentifier).then(walletTransaction => {\n            this._pendingTransactions[transactionIdentifier] = null;\n            (signers === null || signers === void 0 ? void 0 : signers.length) && walletTransaction.partialSign(...signers);\n            wallet.postMessage({\n              type: \"sendFinalTransaction\",\n              sendFinalTransaction: {\n                transactionIdentifier,\n                signaturePubkeyPairs: walletTransaction.signatures.filter(sp => sp.signature != null).map(sp => {\n                  return {\n                    'pubkey': sp.publicKey.toBase58(),\n                    'signature': sp.signature.toString('base64')\n                  };\n                })\n              }\n            }, this.url);\n            const timer = window.setInterval(() => {\n              const pendingTransaction = this._pendingTransactions[transactionIdentifier];\n              const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier];\n\n              if (pendingTransaction != null || pendingTransactionError != null) {\n                this.clearTimer(timer);\n                pendingTransaction && resolve(pendingTransaction.signature);\n                pendingTransactionError && reject(pendingTransactionError);\n              }\n            }, 100);\n\n            this._timers.push(timer);\n          }).catch(error => {\n            reject(error);\n            throw error;\n          });\n        });\n      } else {\n        const instructions = this.instructionsToSerializableInstructions(transaction.instructions);\n        return new Promise((resolve, reject) => {\n          wallet.postMessage({\n            type: \"sendTransaction\",\n            sendTransaction: {\n              instructions,\n              transactionIdentifier\n            }\n          }, this.url);\n          const timer = window.setInterval(() => {\n            const pendingTransaction = this._pendingTransactions[transactionIdentifier];\n            const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier];\n\n            if (pendingTransaction != null || pendingTransactionError != null) {\n              this.clearTimer(timer);\n              pendingTransaction && resolve(pendingTransaction.signature);\n              pendingTransactionError && reject(pendingTransactionError);\n            }\n          }, 100);\n\n          this._timers.push(timer);\n        });\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  buildTransaction(pendingTransaction) {\n    let message = Message.from(Buffer.from(Uint8Array.from(window.atob(pendingTransaction.message), c => c.charCodeAt(0))));\n    return Transaction.populate(message, Array.from({\n      length: message.header.numRequiredSignatures\n    }, (_v, i) => {\n      let sigPubkeyPair = pendingTransaction.signatures.find(s => s.pubkey == message.accountKeys[i].toBase58());\n      return bs58.encode(sigPubkeyPair ? Buffer.from(Uint8Array.from(window.atob(sigPubkeyPair.signature), c => c.charCodeAt(0))) : DEFAULT_SIGNATURE_BUFFER);\n    }));\n  }\n\n  verifyCanSignRequests(transactions) {\n    transactions.forEach(transaction => {\n      if (transaction.signatures.some(s => s.signature != null)) {\n        throw new Error(\"Strike does not support this signing mode\");\n      }\n    });\n  }\n\n  signOneTransaction(transaction) {\n    let transactionIdentifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : uuidv4();\n    const wallet = this._wallet;\n    if (!wallet) throw new Error(\"Not Connected\");\n    const instructions = this.instructionsToSerializableInstructions(transaction.instructions);\n    this._pendingTransactions[transactionIdentifier] = null;\n    return new Promise((resolve, reject) => {\n      wallet.postMessage({\n        type: \"signTransaction\",\n        signTransaction: {\n          instructions,\n          transactionIdentifier\n        }\n      }, this.url);\n      const timer = window.setInterval(() => {\n        const pendingTransaction = this._pendingTransactions[transactionIdentifier];\n        const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier];\n\n        if (pendingTransaction != null || pendingTransactionError != null) {\n          this.clearTimer(timer);\n          pendingTransaction && resolve(this.buildTransaction(pendingTransaction));\n          pendingTransactionError && reject(pendingTransactionError);\n        }\n      }, 100);\n\n      this._timers.push(timer);\n    });\n  }\n\n  signMultipleTransactions(transactions) {\n    const wallet = this._wallet;\n    if (!wallet) throw new Error(\"Not Connected\");\n    const serializedTransactions = transactions.map(t => {\n      return {\n        instructions: this.instructionsToSerializableInstructions(t.instructions),\n        transactionIdentifier: uuidv4()\n      };\n    });\n    const transactionIdentifiers = serializedTransactions.map(t => t.transactionIdentifier);\n    transactionIdentifiers.forEach(transactionIdentifier => this._pendingTransactions[transactionIdentifier] = null);\n    return new Promise((resolve, reject) => {\n      wallet.postMessage({\n        type: \"signAllTransactions\",\n        signAllTransactions: {\n          transactions: serializedTransactions\n        }\n      }, this.url);\n      const timer = window.setInterval(() => {\n        const pendingTransactions = transactionIdentifiers.map(txId => this._pendingTransactions[txId]);\n        const pendingTransactionErrors = transactionIdentifiers.map(txId => this._pendingTransactionErrors[txId]);\n\n        if (pendingTransactions.every(t => t != null)) {\n          this.clearTimer(timer);\n          resolve(pendingTransactions.map(pt => this.buildTransaction(pt)));\n        } else if (pendingTransactionErrors.some(e => e != null)) {\n          this.clearTimer(timer);\n          reject(pendingTransactionErrors.find(e => e != null));\n        }\n      }, 100);\n\n      this._timers.push(timer);\n    });\n  }\n\n} //# sourceMappingURL=strikewallet.js.map","map":null,"metadata":{},"sourceType":"module"}