{"ast":null,"code":"import { IEvents as c } from \"@walletconnect/events\";\n\nclass m extends c {\n  constructor(t) {\n    super(), this.opts = t, this.protocol = \"wc\", this.version = 2;\n  }\n\n}\n\nclass _ {\n  constructor(t, s, i) {\n    this.core = t, this.logger = s;\n  }\n\n}\n\nclass g extends c {\n  constructor(t, s) {\n    super(), this.core = t, this.logger = s, this.records = new Map();\n  }\n\n}\n\nclass p {\n  constructor(t, s) {\n    this.logger = t, this.core = s;\n  }\n\n}\n\nclass d extends c {\n  constructor(t, s) {\n    super(), this.relayer = t, this.logger = s;\n  }\n\n}\n\nclass L extends c {\n  constructor(t) {\n    super();\n  }\n\n}\n\nclass x {\n  constructor(t, s, i, h) {\n    this.core = t, this.logger = s, this.name = i;\n  }\n\n}\n\nclass E {\n  constructor() {\n    this.map = new Map();\n  }\n\n}\n\nclass b extends c {\n  constructor(t, s) {\n    super(), this.relayer = t, this.logger = s;\n  }\n\n}\n\nclass w {\n  constructor(t, s) {\n    this.core = t, this.logger = s;\n  }\n\n}\n\nfunction r() {\n  this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;\n}\n\nvar f = r;\nr.EventEmitter = r, r.prototype._events = void 0, r.prototype._maxListeners = void 0, r.defaultMaxListeners = 10, r.prototype.setMaxListeners = function (e) {\n  if (!I(e) || e < 0 || isNaN(e)) throw TypeError(\"n must be a positive number\");\n  return this._maxListeners = e, this;\n}, r.prototype.emit = function (e) {\n  var t, s, i, h, n, u;\n\n  if (this._events || (this._events = {}), e === \"error\" && (!this._events.error || l(this._events.error) && !this._events.error.length)) {\n    if (t = arguments[1], t instanceof Error) throw t;\n    var a = new Error('Uncaught, unspecified \"error\" event. (' + t + \")\");\n    throw a.context = t, a;\n  }\n\n  if (s = this._events[e], v(s)) return !1;\n  if (o(s)) switch (arguments.length) {\n    case 1:\n      s.call(this);\n      break;\n\n    case 2:\n      s.call(this, arguments[1]);\n      break;\n\n    case 3:\n      s.call(this, arguments[1], arguments[2]);\n      break;\n\n    default:\n      h = Array.prototype.slice.call(arguments, 1), s.apply(this, h);\n  } else if (l(s)) for (h = Array.prototype.slice.call(arguments, 1), u = s.slice(), i = u.length, n = 0; n < i; n++) u[n].apply(this, h);\n  return !0;\n}, r.prototype.addListener = function (e, t) {\n  var s;\n  if (!o(t)) throw TypeError(\"listener must be a function\");\n  return this._events || (this._events = {}), this._events.newListener && this.emit(\"newListener\", e, o(t.listener) ? t.listener : t), this._events[e] ? l(this._events[e]) ? this._events[e].push(t) : this._events[e] = [this._events[e], t] : this._events[e] = t, l(this._events[e]) && !this._events[e].warned && (v(this._maxListeners) ? s = r.defaultMaxListeners : s = this._maxListeners, s && s > 0 && this._events[e].length > s && (this._events[e].warned = !0, console.error(\"(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.\", this._events[e].length), typeof console.trace == \"function\" && console.trace())), this;\n}, r.prototype.on = r.prototype.addListener, r.prototype.once = function (e, t) {\n  if (!o(t)) throw TypeError(\"listener must be a function\");\n  var s = !1;\n\n  function i() {\n    this.removeListener(e, i), s || (s = !0, t.apply(this, arguments));\n  }\n\n  return i.listener = t, this.on(e, i), this;\n}, r.prototype.removeListener = function (e, t) {\n  var s, i, h, n;\n  if (!o(t)) throw TypeError(\"listener must be a function\");\n  if (!this._events || !this._events[e]) return this;\n  if (s = this._events[e], h = s.length, i = -1, s === t || o(s.listener) && s.listener === t) delete this._events[e], this._events.removeListener && this.emit(\"removeListener\", e, t);else if (l(s)) {\n    for (n = h; n-- > 0;) if (s[n] === t || s[n].listener && s[n].listener === t) {\n      i = n;\n      break;\n    }\n\n    if (i < 0) return this;\n    s.length === 1 ? (s.length = 0, delete this._events[e]) : s.splice(i, 1), this._events.removeListener && this.emit(\"removeListener\", e, t);\n  }\n  return this;\n}, r.prototype.removeAllListeners = function (e) {\n  var t, s;\n  if (!this._events) return this;\n  if (!this._events.removeListener) return arguments.length === 0 ? this._events = {} : this._events[e] && delete this._events[e], this;\n\n  if (arguments.length === 0) {\n    for (t in this._events) t !== \"removeListener\" && this.removeAllListeners(t);\n\n    return this.removeAllListeners(\"removeListener\"), this._events = {}, this;\n  }\n\n  if (s = this._events[e], o(s)) this.removeListener(e, s);else if (s) for (; s.length;) this.removeListener(e, s[s.length - 1]);\n  return delete this._events[e], this;\n}, r.prototype.listeners = function (e) {\n  var t;\n  return !this._events || !this._events[e] ? t = [] : o(this._events[e]) ? t = [this._events[e]] : t = this._events[e].slice(), t;\n}, r.prototype.listenerCount = function (e) {\n  if (this._events) {\n    var t = this._events[e];\n    if (o(t)) return 1;\n    if (t) return t.length;\n  }\n\n  return 0;\n}, r.listenerCount = function (e, t) {\n  return e.listenerCount(t);\n};\n\nfunction o(e) {\n  return typeof e == \"function\";\n}\n\nfunction I(e) {\n  return typeof e == \"number\";\n}\n\nfunction l(e) {\n  return typeof e == \"object\" && e !== null;\n}\n\nfunction v(e) {\n  return e === void 0;\n}\n\nclass y extends f {\n  constructor() {\n    super();\n  }\n\n}\n\nclass C {\n  constructor(t) {\n    this.opts = t, this.protocol = \"wc\", this.version = 2;\n  }\n\n}\n\nclass M extends f.EventEmitter {\n  constructor() {\n    super();\n  }\n\n}\n\nclass k {\n  constructor(t) {\n    this.client = t;\n  }\n\n}\n\nclass T extends c {\n  constructor(t, s) {\n    super(), this.core = t, this.logger = s;\n  }\n\n}\n\nexport { m as ICore, _ as ICrypto, k as IEngine, M as IEngineEvents, T as IExpirer, g as IJsonRpcHistory, w as IKeyChain, p as IMessageTracker, d as IPublisher, L as IRelayer, C as ISignClient, y as ISignClientEvents, x as IStore, b as ISubscriber, E as ISubscriberTopicMap }; //# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module"}