{"ast":null,"code":"import { BaseMessageSignerWalletAdapter, scopePollingDetectionStrategy, WalletAccountError, WalletAdapterNetwork, WalletConfigError, WalletConnectionError, WalletDisconnectedError, WalletDisconnectionError, WalletError, WalletLoadError, WalletNotConnectedError, WalletNotReadyError, WalletPublicKeyError, WalletReadyState, WalletSignMessageError, WalletSignTransactionError, WalletTimeoutError, WalletWindowBlockedError, WalletWindowClosedError } from '@solana/wallet-adapter-base';\nimport { PublicKey } from '@solana/web3.js';\nexport class BaseSolletWalletAdapter extends BaseMessageSignerWalletAdapter {\n  constructor() {\n    let {\n      provider,\n      network = WalletAdapterNetwork.Mainnet,\n      timeout = 10000\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.supportedTransactionVersions = null;\n    this._readyState = typeof window === 'undefined' || typeof document === 'undefined' ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;\n\n    this._disconnected = () => {\n      const wallet = this._wallet;\n\n      if (wallet) {\n        wallet.off('disconnect', this._disconnected);\n        this._wallet = null;\n        this._publicKey = null;\n        this.emit('error', new WalletDisconnectedError());\n        this.emit('disconnect');\n      }\n    };\n\n    this._provider = provider;\n    this._network = network;\n    this._timeout = timeout;\n    this._connecting = false;\n    this._wallet = null;\n    this._publicKey = null;\n\n    if (this._readyState !== WalletReadyState.Unsupported) {\n      if (typeof this._provider === 'string') {\n        this._readyState = WalletReadyState.Loadable;\n      } else {\n        scopePollingDetectionStrategy(() => {\n          if (typeof window.sollet?.postMessage === 'function') {\n            this._readyState = WalletReadyState.Installed;\n            this.emit('readyStateChange', this._readyState);\n            return true;\n          }\n\n          return false;\n        });\n      }\n    }\n  }\n\n  get publicKey() {\n    return this._publicKey;\n  }\n\n  get connecting() {\n    return this._connecting;\n  }\n\n  get connected() {\n    return !!this._wallet?.connected;\n  }\n\n  get readyState() {\n    return this._readyState;\n  }\n\n  async connect() {\n    try {\n      if (this.connected || this.connecting) return;\n      if (this._readyState !== WalletReadyState.Loadable && this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();\n      this._connecting = true; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      const provider = this._provider || window.sollet;\n      let SolWalletAdapterClass;\n\n      try {\n        SolWalletAdapterClass = (await import('@project-serum/sol-wallet-adapter')).default;\n      } catch (error) {\n        throw new WalletLoadError(error?.message, error);\n      }\n\n      let wallet;\n\n      try {\n        wallet = new SolWalletAdapterClass(provider, this._network);\n      } catch (error) {\n        throw new WalletConfigError(error?.message, error);\n      }\n\n      try {\n        // HACK: sol-wallet-adapter doesn't reject or emit an event if the popup or extension is closed or blocked\n        const handleDisconnect = wallet.handleDisconnect;\n        let timeout;\n        let interval;\n\n        try {\n          await new Promise((resolve, reject) => {\n            const connect = () => {\n              if (timeout) clearTimeout(timeout);\n              wallet.off('connect', connect);\n              resolve();\n            };\n\n            wallet.handleDisconnect = function () {\n              wallet.off('connect', connect);\n              reject(new WalletWindowClosedError());\n\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n\n              return handleDisconnect.apply(wallet, args);\n            };\n\n            wallet.on('connect', connect);\n            wallet.connect().catch(reason => {\n              wallet.off('connect', connect);\n              reject(reason);\n            });\n\n            if (typeof provider === 'string') {\n              let count = 0;\n              interval = setInterval(() => {\n                const popup = wallet._popup;\n\n                if (popup) {\n                  if (popup.closed) reject(new WalletWindowClosedError());\n                } else {\n                  if (count > 50) reject(new WalletWindowBlockedError());\n                }\n\n                count++;\n              }, 100);\n            } else {\n              // HACK: sol-wallet-adapter doesn't reject or emit an event if the extension is closed or ignored\n              timeout = setTimeout(() => reject(new WalletTimeoutError()), this._timeout);\n            }\n          });\n        } finally {\n          wallet.handleDisconnect = handleDisconnect;\n          if (interval) clearInterval(interval);\n        }\n      } catch (error) {\n        if (error instanceof WalletError) throw error;\n        throw new WalletConnectionError(error?.message, error);\n      }\n\n      if (!wallet.publicKey) throw new WalletAccountError();\n      let publicKey;\n\n      try {\n        publicKey = new PublicKey(wallet.publicKey.toBytes());\n      } catch (error) {\n        throw new WalletPublicKeyError(error?.message, error);\n      }\n\n      wallet.on('disconnect', this._disconnected);\n      this._wallet = wallet;\n      this._publicKey = publicKey;\n      this.emit('connect', publicKey);\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    } finally {\n      this._connecting = false;\n    }\n  }\n\n  async disconnect() {\n    const wallet = this._wallet;\n\n    if (wallet) {\n      wallet.off('disconnect', this._disconnected);\n      this._wallet = null;\n      this._publicKey = null; // HACK: sol-wallet-adapter doesn't reliably fulfill its promise or emit an event on disconnect\n\n      const handleDisconnect = wallet.handleDisconnect;\n\n      try {\n        await new Promise((resolve, reject) => {\n          const timeout = setTimeout(() => resolve(), 250);\n\n          wallet.handleDisconnect = function () {\n            clearTimeout(timeout);\n            resolve(); // HACK: sol-wallet-adapter rejects with an uncaught promise error\n\n            wallet._responsePromises = new Map();\n\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n\n            return handleDisconnect.apply(wallet, args);\n          };\n\n          wallet.disconnect().then(() => {\n            clearTimeout(timeout);\n            resolve();\n          }, error => {\n            clearTimeout(timeout); // HACK: sol-wallet-adapter rejects with an error on disconnect\n\n            if (error?.message === 'Wallet disconnected') {\n              resolve();\n            } else {\n              reject(error);\n            }\n          });\n        });\n      } catch (error) {\n        this.emit('error', new WalletDisconnectionError(error?.message, error));\n      } finally {\n        wallet.handleDisconnect = handleDisconnect;\n      }\n    }\n\n    this.emit('disconnect');\n  }\n\n  async signTransaction(transaction) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n\n      try {\n        return (await wallet.signTransaction(transaction)) || transaction;\n      } catch (error) {\n        throw new WalletSignTransactionError(error?.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  async signAllTransactions(transactions) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n\n      try {\n        return (await wallet.signAllTransactions(transactions)) || transactions;\n      } catch (error) {\n        throw new WalletSignTransactionError(error?.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  async signMessage(message) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n\n      try {\n        const {\n          signature\n        } = await wallet.sign(message, 'utf8');\n        return Uint8Array.from(signature);\n      } catch (error) {\n        throw new WalletSignMessageError(error?.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n} //# sourceMappingURL=base.js.map","map":null,"metadata":{},"sourceType":"module"}