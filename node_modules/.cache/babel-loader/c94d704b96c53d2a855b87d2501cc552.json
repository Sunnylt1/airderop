{"ast":null,"code":"import ee from \"pino\";\nimport at from \"@walletconnect/keyvaluestorage\";\nimport { HEARTBEAT_EVENTS as te, HeartBeat as ot } from \"@walletconnect/heartbeat\";\nimport { generateChildLogger as I, getLoggerContext as A, getDefaultLoggerOptions as se } from \"@walletconnect/logger\";\nimport { IMessageTracker as ut, IPublisher as ht, ISubscriber as ct, IRelayer as lt, IStore as Dt, ICore as dt } from \"@walletconnect/types\";\nimport { safeJsonStringify as gt, safeJsonParse as pt } from \"@walletconnect/safe-json\";\nimport * as N from \"@walletconnect/relay-auth\";\nimport { getInternalError as m, mapToObj as ie, objToMap as re, generateKeyPair as bt, generateRandomBytes32 as ne, deriveSymKey as ft, hashKey as yt, validateEncoding as mt, isTypeOneEnvelope as ae, encrypt as Et, validateDecoding as vt, decrypt as wt, hashMessage as B, getRelayProtocolName as V, getRelayProtocolApi as G, isUndefined as q, getSdkError as Ct, formatRelayRpcUrl as _t, isProposalStruct as St, isSessionStruct as It } from \"@walletconnect/utils\";\nimport { ONE_DAY as At, SIX_HOURS as Ot, ONE_SECOND as Rt, THIRTY_DAYS as Tt, FIVE_SECONDS as zt, Watch as Pt, toMiliseconds as xt } from \"@walletconnect/time\";\nimport { JsonRpcProvider as Lt } from \"@walletconnect/jsonrpc-provider\";\nimport { isJsonRpcRequest as Ft, formatJsonRpcResult as Ut } from \"@walletconnect/jsonrpc-utils\";\nimport Nt from \"@walletconnect/jsonrpc-ws-connection\";\nimport Bt from \"lodash.isequal\";\n\nfunction D() {\n  this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;\n}\n\nvar M = D;\nD.EventEmitter = D, D.prototype._events = void 0, D.prototype._maxListeners = void 0, D.defaultMaxListeners = 10, D.prototype.setMaxListeners = function (s) {\n  if (!Mt(s) || s < 0 || isNaN(s)) throw TypeError(\"n must be a positive number\");\n  return this._maxListeners = s, this;\n}, D.prototype.emit = function (s) {\n  var e, t, i, r, n, a;\n\n  if (this._events || (this._events = {}), s === \"error\" && (!this._events.error || P(this._events.error) && !this._events.error.length)) {\n    if (e = arguments[1], e instanceof Error) throw e;\n    var o = new Error('Uncaught, unspecified \"error\" event. (' + e + \")\");\n    throw o.context = e, o;\n  }\n\n  if (t = this._events[s], oe(t)) return !1;\n  if (_(t)) switch (arguments.length) {\n    case 1:\n      t.call(this);\n      break;\n\n    case 2:\n      t.call(this, arguments[1]);\n      break;\n\n    case 3:\n      t.call(this, arguments[1], arguments[2]);\n      break;\n\n    default:\n      r = Array.prototype.slice.call(arguments, 1), t.apply(this, r);\n  } else if (P(t)) for (r = Array.prototype.slice.call(arguments, 1), a = t.slice(), i = a.length, n = 0; n < i; n++) a[n].apply(this, r);\n  return !0;\n}, D.prototype.addListener = function (s, e) {\n  var t;\n  if (!_(e)) throw TypeError(\"listener must be a function\");\n  return this._events || (this._events = {}), this._events.newListener && this.emit(\"newListener\", s, _(e.listener) ? e.listener : e), this._events[s] ? P(this._events[s]) ? this._events[s].push(e) : this._events[s] = [this._events[s], e] : this._events[s] = e, P(this._events[s]) && !this._events[s].warned && (oe(this._maxListeners) ? t = D.defaultMaxListeners : t = this._maxListeners, t && t > 0 && this._events[s].length > t && (this._events[s].warned = !0, console.error(\"(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.\", this._events[s].length), typeof console.trace == \"function\" && console.trace())), this;\n}, D.prototype.on = D.prototype.addListener, D.prototype.once = function (s, e) {\n  if (!_(e)) throw TypeError(\"listener must be a function\");\n  var t = !1;\n\n  function i() {\n    this.removeListener(s, i), t || (t = !0, e.apply(this, arguments));\n  }\n\n  return i.listener = e, this.on(s, i), this;\n}, D.prototype.removeListener = function (s, e) {\n  var t, i, r, n;\n  if (!_(e)) throw TypeError(\"listener must be a function\");\n  if (!this._events || !this._events[s]) return this;\n  if (t = this._events[s], r = t.length, i = -1, t === e || _(t.listener) && t.listener === e) delete this._events[s], this._events.removeListener && this.emit(\"removeListener\", s, e);else if (P(t)) {\n    for (n = r; n-- > 0;) if (t[n] === e || t[n].listener && t[n].listener === e) {\n      i = n;\n      break;\n    }\n\n    if (i < 0) return this;\n    t.length === 1 ? (t.length = 0, delete this._events[s]) : t.splice(i, 1), this._events.removeListener && this.emit(\"removeListener\", s, e);\n  }\n  return this;\n}, D.prototype.removeAllListeners = function (s) {\n  var e, t;\n  if (!this._events) return this;\n  if (!this._events.removeListener) return arguments.length === 0 ? this._events = {} : this._events[s] && delete this._events[s], this;\n\n  if (arguments.length === 0) {\n    for (e in this._events) e !== \"removeListener\" && this.removeAllListeners(e);\n\n    return this.removeAllListeners(\"removeListener\"), this._events = {}, this;\n  }\n\n  if (t = this._events[s], _(t)) this.removeListener(s, t);else if (t) for (; t.length;) this.removeListener(s, t[t.length - 1]);\n  return delete this._events[s], this;\n}, D.prototype.listeners = function (s) {\n  var e;\n  return !this._events || !this._events[s] ? e = [] : _(this._events[s]) ? e = [this._events[s]] : e = this._events[s].slice(), e;\n}, D.prototype.listenerCount = function (s) {\n  if (this._events) {\n    var e = this._events[s];\n    if (_(e)) return 1;\n    if (e) return e.length;\n  }\n\n  return 0;\n}, D.listenerCount = function (s, e) {\n  return s.listenerCount(e);\n};\n\nfunction _(s) {\n  return typeof s == \"function\";\n}\n\nfunction Mt(s) {\n  return typeof s == \"number\";\n}\n\nfunction P(s) {\n  return typeof s == \"object\" && s !== null;\n}\n\nfunction oe(s) {\n  return s === void 0;\n}\n\nfunction Kt(s, e) {\n  if (s.length >= 255) throw new TypeError(\"Alphabet too long\");\n\n  for (var t = new Uint8Array(256), i = 0; i < t.length; i++) t[i] = 255;\n\n  for (var r = 0; r < s.length; r++) {\n    var n = s.charAt(r),\n        a = n.charCodeAt(0);\n    if (t[a] !== 255) throw new TypeError(n + \" is ambiguous\");\n    t[a] = r;\n  }\n\n  var o = s.length,\n      u = s.charAt(0),\n      p = Math.log(o) / Math.log(256),\n      c = Math.log(256) / Math.log(o);\n\n  function l(h) {\n    if (h instanceof Uint8Array || (ArrayBuffer.isView(h) ? h = new Uint8Array(h.buffer, h.byteOffset, h.byteLength) : Array.isArray(h) && (h = Uint8Array.from(h))), !(h instanceof Uint8Array)) throw new TypeError(\"Expected Uint8Array\");\n    if (h.length === 0) return \"\";\n\n    for (var g = 0, R = 0, f = 0, E = h.length; f !== E && h[f] === 0;) f++, g++;\n\n    for (var v = (E - f) * c + 1 >>> 0, b = new Uint8Array(v); f !== E;) {\n      for (var w = h[f], S = 0, y = v - 1; (w !== 0 || S < R) && y !== -1; y--, S++) w += 256 * b[y] >>> 0, b[y] = w % o >>> 0, w = w / o >>> 0;\n\n      if (w !== 0) throw new Error(\"Non-zero carry\");\n      R = S, f++;\n    }\n\n    for (var C = v - R; C !== v && b[C] === 0;) C++;\n\n    for (var U = u.repeat(g); C < v; ++C) U += s.charAt(b[C]);\n\n    return U;\n  }\n\n  function F(h) {\n    if (typeof h != \"string\") throw new TypeError(\"Expected String\");\n    if (h.length === 0) return new Uint8Array();\n    var g = 0;\n\n    if (h[g] !== \" \") {\n      for (var R = 0, f = 0; h[g] === u;) R++, g++;\n\n      for (var E = (h.length - g) * p + 1 >>> 0, v = new Uint8Array(E); h[g];) {\n        var b = t[h.charCodeAt(g)];\n        if (b === 255) return;\n\n        for (var w = 0, S = E - 1; (b !== 0 || w < f) && S !== -1; S--, w++) b += o * v[S] >>> 0, v[S] = b % 256 >>> 0, b = b / 256 >>> 0;\n\n        if (b !== 0) throw new Error(\"Non-zero carry\");\n        f = w, g++;\n      }\n\n      if (h[g] !== \" \") {\n        for (var y = E - f; y !== E && v[y] === 0;) y++;\n\n        for (var C = new Uint8Array(R + (E - y)), U = R; y !== E;) C[U++] = v[y++];\n\n        return C;\n      }\n    }\n  }\n\n  function Y(h) {\n    var g = F(h);\n    if (g) return g;\n    throw new Error(`Non-${e} character`);\n  }\n\n  return {\n    encode: l,\n    decodeUnsafe: F,\n    decode: Y\n  };\n}\n\nvar kt = Kt,\n    $t = kt;\n\nconst ue = s => {\n  if (s instanceof Uint8Array && s.constructor.name === \"Uint8Array\") return s;\n  if (s instanceof ArrayBuffer) return new Uint8Array(s);\n  if (ArrayBuffer.isView(s)) return new Uint8Array(s.buffer, s.byteOffset, s.byteLength);\n  throw new Error(\"Unknown type, must be binary type\");\n},\n      jt = s => new TextEncoder().encode(s),\n      Yt = s => new TextDecoder().decode(s);\n\nclass Vt {\n  constructor(e, t, i) {\n    this.name = e, this.prefix = t, this.baseEncode = i;\n  }\n\n  encode(e) {\n    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;\n    throw Error(\"Unknown type, must be binary type\");\n  }\n\n}\n\nclass Gt {\n  constructor(e, t, i) {\n    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i;\n  }\n\n  decode(e) {\n    if (typeof e == \"string\") {\n      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      return this.baseDecode(e.slice(this.prefix.length));\n    } else throw Error(\"Can only multibase decode strings\");\n  }\n\n  or(e) {\n    return he(this, e);\n  }\n\n}\n\nclass qt {\n  constructor(e) {\n    this.decoders = e;\n  }\n\n  or(e) {\n    return he(this, e);\n  }\n\n  decode(e) {\n    const t = e[0],\n          i = this.decoders[t];\n    if (i) return i.decode(e);\n    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n  }\n\n}\n\nconst he = (s, e) => new qt({ ...(s.decoders || {\n    [s.prefix]: s\n  }),\n  ...(e.decoders || {\n    [e.prefix]: e\n  })\n});\n\nclass Jt {\n  constructor(e, t, i, r) {\n    this.name = e, this.prefix = t, this.baseEncode = i, this.baseDecode = r, this.encoder = new Vt(e, t, i), this.decoder = new Gt(e, t, r);\n  }\n\n  encode(e) {\n    return this.encoder.encode(e);\n  }\n\n  decode(e) {\n    return this.decoder.decode(e);\n  }\n\n}\n\nconst K = _ref => {\n  let {\n    name: s,\n    prefix: e,\n    encode: t,\n    decode: i\n  } = _ref;\n  return new Jt(s, e, t, i);\n},\n      x = _ref2 => {\n  let {\n    prefix: s,\n    name: e,\n    alphabet: t\n  } = _ref2;\n  const {\n    encode: i,\n    decode: r\n  } = $t(t, e);\n  return K({\n    prefix: s,\n    name: e,\n    encode: i,\n    decode: n => ue(r(n))\n  });\n},\n      Wt = (s, e, t, i) => {\n  const r = {};\n\n  for (let c = 0; c < e.length; ++c) r[e[c]] = c;\n\n  let n = s.length;\n\n  for (; s[n - 1] === \"=\";) --n;\n\n  const a = new Uint8Array(n * t / 8 | 0);\n  let o = 0,\n      u = 0,\n      p = 0;\n\n  for (let c = 0; c < n; ++c) {\n    const l = r[s[c]];\n    if (l === void 0) throw new SyntaxError(`Non-${i} character`);\n    u = u << t | l, o += t, o >= 8 && (o -= 8, a[p++] = 255 & u >> o);\n  }\n\n  if (o >= t || 255 & u << 8 - o) throw new SyntaxError(\"Unexpected end of data\");\n  return a;\n},\n      Xt = (s, e, t) => {\n  const i = e[e.length - 1] === \"=\",\n        r = (1 << t) - 1;\n  let n = \"\",\n      a = 0,\n      o = 0;\n\n  for (let u = 0; u < s.length; ++u) for (o = o << 8 | s[u], a += 8; a > t;) a -= t, n += e[r & o >> a];\n\n  if (a && (n += e[r & o << t - a]), i) for (; n.length * t & 7;) n += \"=\";\n  return n;\n},\n      d = _ref3 => {\n  let {\n    name: s,\n    prefix: e,\n    bitsPerChar: t,\n    alphabet: i\n  } = _ref3;\n  return K({\n    prefix: e,\n    name: s,\n\n    encode(r) {\n      return Xt(r, i, t);\n    },\n\n    decode(r) {\n      return Wt(r, i, t, s);\n    }\n\n  });\n},\n      Ht = K({\n  prefix: \"\\0\",\n  name: \"identity\",\n  encode: s => Yt(s),\n  decode: s => jt(s)\n});\n\nvar Zt = Object.freeze({\n  __proto__: null,\n  identity: Ht\n});\nconst Qt = d({\n  prefix: \"0\",\n  name: \"base2\",\n  alphabet: \"01\",\n  bitsPerChar: 1\n});\nvar es = Object.freeze({\n  __proto__: null,\n  base2: Qt\n});\nconst ts = d({\n  prefix: \"7\",\n  name: \"base8\",\n  alphabet: \"01234567\",\n  bitsPerChar: 3\n});\nvar ss = Object.freeze({\n  __proto__: null,\n  base8: ts\n});\nconst is = x({\n  prefix: \"9\",\n  name: \"base10\",\n  alphabet: \"0123456789\"\n});\nvar rs = Object.freeze({\n  __proto__: null,\n  base10: is\n});\nconst ns = d({\n  prefix: \"f\",\n  name: \"base16\",\n  alphabet: \"0123456789abcdef\",\n  bitsPerChar: 4\n}),\n      as = d({\n  prefix: \"F\",\n  name: \"base16upper\",\n  alphabet: \"0123456789ABCDEF\",\n  bitsPerChar: 4\n});\nvar os = Object.freeze({\n  __proto__: null,\n  base16: ns,\n  base16upper: as\n});\nconst us = d({\n  prefix: \"b\",\n  name: \"base32\",\n  alphabet: \"abcdefghijklmnopqrstuvwxyz234567\",\n  bitsPerChar: 5\n}),\n      hs = d({\n  prefix: \"B\",\n  name: \"base32upper\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n  bitsPerChar: 5\n}),\n      cs = d({\n  prefix: \"c\",\n  name: \"base32pad\",\n  alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\",\n  bitsPerChar: 5\n}),\n      ls = d({\n  prefix: \"C\",\n  name: \"base32padupper\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\",\n  bitsPerChar: 5\n}),\n      Ds = d({\n  prefix: \"v\",\n  name: \"base32hex\",\n  alphabet: \"0123456789abcdefghijklmnopqrstuv\",\n  bitsPerChar: 5\n}),\n      ds = d({\n  prefix: \"V\",\n  name: \"base32hexupper\",\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n  bitsPerChar: 5\n}),\n      gs = d({\n  prefix: \"t\",\n  name: \"base32hexpad\",\n  alphabet: \"0123456789abcdefghijklmnopqrstuv=\",\n  bitsPerChar: 5\n}),\n      ps = d({\n  prefix: \"T\",\n  name: \"base32hexpadupper\",\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\",\n  bitsPerChar: 5\n}),\n      bs = d({\n  prefix: \"h\",\n  name: \"base32z\",\n  alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\",\n  bitsPerChar: 5\n});\nvar fs = Object.freeze({\n  __proto__: null,\n  base32: us,\n  base32upper: hs,\n  base32pad: cs,\n  base32padupper: ls,\n  base32hex: Ds,\n  base32hexupper: ds,\n  base32hexpad: gs,\n  base32hexpadupper: ps,\n  base32z: bs\n});\nconst ys = x({\n  prefix: \"k\",\n  name: \"base36\",\n  alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\"\n}),\n      ms = x({\n  prefix: \"K\",\n  name: \"base36upper\",\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n});\nvar Es = Object.freeze({\n  __proto__: null,\n  base36: ys,\n  base36upper: ms\n});\nconst vs = x({\n  name: \"base58btc\",\n  prefix: \"z\",\n  alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n}),\n      ws = x({\n  name: \"base58flickr\",\n  prefix: \"Z\",\n  alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"\n});\nvar Cs = Object.freeze({\n  __proto__: null,\n  base58btc: vs,\n  base58flickr: ws\n});\n\nconst _s = d({\n  prefix: \"m\",\n  name: \"base64\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n  bitsPerChar: 6\n}),\n      Ss = d({\n  prefix: \"M\",\n  name: \"base64pad\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n  bitsPerChar: 6\n}),\n      Is = d({\n  prefix: \"u\",\n  name: \"base64url\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\",\n  bitsPerChar: 6\n}),\n      As = d({\n  prefix: \"U\",\n  name: \"base64urlpad\",\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\",\n  bitsPerChar: 6\n});\n\nvar Os = Object.freeze({\n  __proto__: null,\n  base64: _s,\n  base64pad: Ss,\n  base64url: Is,\n  base64urlpad: As\n});\nconst ce = Array.from(\"\\u{1F680}\\u{1FA90}\\u2604\\u{1F6F0}\\u{1F30C}\\u{1F311}\\u{1F312}\\u{1F313}\\u{1F314}\\u{1F315}\\u{1F316}\\u{1F317}\\u{1F318}\\u{1F30D}\\u{1F30F}\\u{1F30E}\\u{1F409}\\u2600\\u{1F4BB}\\u{1F5A5}\\u{1F4BE}\\u{1F4BF}\\u{1F602}\\u2764\\u{1F60D}\\u{1F923}\\u{1F60A}\\u{1F64F}\\u{1F495}\\u{1F62D}\\u{1F618}\\u{1F44D}\\u{1F605}\\u{1F44F}\\u{1F601}\\u{1F525}\\u{1F970}\\u{1F494}\\u{1F496}\\u{1F499}\\u{1F622}\\u{1F914}\\u{1F606}\\u{1F644}\\u{1F4AA}\\u{1F609}\\u263A\\u{1F44C}\\u{1F917}\\u{1F49C}\\u{1F614}\\u{1F60E}\\u{1F607}\\u{1F339}\\u{1F926}\\u{1F389}\\u{1F49E}\\u270C\\u2728\\u{1F937}\\u{1F631}\\u{1F60C}\\u{1F338}\\u{1F64C}\\u{1F60B}\\u{1F497}\\u{1F49A}\\u{1F60F}\\u{1F49B}\\u{1F642}\\u{1F493}\\u{1F929}\\u{1F604}\\u{1F600}\\u{1F5A4}\\u{1F603}\\u{1F4AF}\\u{1F648}\\u{1F447}\\u{1F3B6}\\u{1F612}\\u{1F92D}\\u2763\\u{1F61C}\\u{1F48B}\\u{1F440}\\u{1F62A}\\u{1F611}\\u{1F4A5}\\u{1F64B}\\u{1F61E}\\u{1F629}\\u{1F621}\\u{1F92A}\\u{1F44A}\\u{1F973}\\u{1F625}\\u{1F924}\\u{1F449}\\u{1F483}\\u{1F633}\\u270B\\u{1F61A}\\u{1F61D}\\u{1F634}\\u{1F31F}\\u{1F62C}\\u{1F643}\\u{1F340}\\u{1F337}\\u{1F63B}\\u{1F613}\\u2B50\\u2705\\u{1F97A}\\u{1F308}\\u{1F608}\\u{1F918}\\u{1F4A6}\\u2714\\u{1F623}\\u{1F3C3}\\u{1F490}\\u2639\\u{1F38A}\\u{1F498}\\u{1F620}\\u261D\\u{1F615}\\u{1F33A}\\u{1F382}\\u{1F33B}\\u{1F610}\\u{1F595}\\u{1F49D}\\u{1F64A}\\u{1F639}\\u{1F5E3}\\u{1F4AB}\\u{1F480}\\u{1F451}\\u{1F3B5}\\u{1F91E}\\u{1F61B}\\u{1F534}\\u{1F624}\\u{1F33C}\\u{1F62B}\\u26BD\\u{1F919}\\u2615\\u{1F3C6}\\u{1F92B}\\u{1F448}\\u{1F62E}\\u{1F646}\\u{1F37B}\\u{1F343}\\u{1F436}\\u{1F481}\\u{1F632}\\u{1F33F}\\u{1F9E1}\\u{1F381}\\u26A1\\u{1F31E}\\u{1F388}\\u274C\\u270A\\u{1F44B}\\u{1F630}\\u{1F928}\\u{1F636}\\u{1F91D}\\u{1F6B6}\\u{1F4B0}\\u{1F353}\\u{1F4A2}\\u{1F91F}\\u{1F641}\\u{1F6A8}\\u{1F4A8}\\u{1F92C}\\u2708\\u{1F380}\\u{1F37A}\\u{1F913}\\u{1F619}\\u{1F49F}\\u{1F331}\\u{1F616}\\u{1F476}\\u{1F974}\\u25B6\\u27A1\\u2753\\u{1F48E}\\u{1F4B8}\\u2B07\\u{1F628}\\u{1F31A}\\u{1F98B}\\u{1F637}\\u{1F57A}\\u26A0\\u{1F645}\\u{1F61F}\\u{1F635}\\u{1F44E}\\u{1F932}\\u{1F920}\\u{1F927}\\u{1F4CC}\\u{1F535}\\u{1F485}\\u{1F9D0}\\u{1F43E}\\u{1F352}\\u{1F617}\\u{1F911}\\u{1F30A}\\u{1F92F}\\u{1F437}\\u260E\\u{1F4A7}\\u{1F62F}\\u{1F486}\\u{1F446}\\u{1F3A4}\\u{1F647}\\u{1F351}\\u2744\\u{1F334}\\u{1F4A3}\\u{1F438}\\u{1F48C}\\u{1F4CD}\\u{1F940}\\u{1F922}\\u{1F445}\\u{1F4A1}\\u{1F4A9}\\u{1F450}\\u{1F4F8}\\u{1F47B}\\u{1F910}\\u{1F92E}\\u{1F3BC}\\u{1F975}\\u{1F6A9}\\u{1F34E}\\u{1F34A}\\u{1F47C}\\u{1F48D}\\u{1F4E3}\\u{1F942}\"),\n      Rs = ce.reduce((s, e, t) => (s[t] = e, s), []),\n      Ts = ce.reduce((s, e, t) => (s[e.codePointAt(0)] = t, s), []);\n\nfunction zs(s) {\n  return s.reduce((e, t) => (e += Rs[t], e), \"\");\n}\n\nfunction Ps(s) {\n  const e = [];\n\n  for (const t of s) {\n    const i = Ts[t.codePointAt(0)];\n    if (i === void 0) throw new Error(`Non-base256emoji character: ${t}`);\n    e.push(i);\n  }\n\n  return new Uint8Array(e);\n}\n\nconst xs = K({\n  prefix: \"\\u{1F680}\",\n  name: \"base256emoji\",\n  encode: zs,\n  decode: Ps\n});\nvar Ls = Object.freeze({\n  __proto__: null,\n  base256emoji: xs\n}),\n    Fs = De,\n    le = 128,\n    Us = 127,\n    Ns = ~Us,\n    Bs = Math.pow(2, 31);\n\nfunction De(s, e, t) {\n  e = e || [], t = t || 0;\n\n  for (var i = t; s >= Bs;) e[t++] = s & 255 | le, s /= 128;\n\n  for (; s & Ns;) e[t++] = s & 255 | le, s >>>= 7;\n\n  return e[t] = s | 0, De.bytes = t - i + 1, e;\n}\n\nvar Ms = J,\n    Ks = 128,\n    de = 127;\n\nfunction J(s, i) {\n  var t = 0,\n      i = i || 0,\n      r = 0,\n      n = i,\n      a,\n      o = s.length;\n\n  do {\n    if (n >= o) throw J.bytes = 0, new RangeError(\"Could not decode varint\");\n    a = s[n++], t += r < 28 ? (a & de) << r : (a & de) * Math.pow(2, r), r += 7;\n  } while (a >= Ks);\n\n  return J.bytes = n - i, t;\n}\n\nvar ks = Math.pow(2, 7),\n    $s = Math.pow(2, 14),\n    js = Math.pow(2, 21),\n    Ys = Math.pow(2, 28),\n    Vs = Math.pow(2, 35),\n    Gs = Math.pow(2, 42),\n    qs = Math.pow(2, 49),\n    Js = Math.pow(2, 56),\n    Ws = Math.pow(2, 63),\n    Xs = function (s) {\n  return s < ks ? 1 : s < $s ? 2 : s < js ? 3 : s < Ys ? 4 : s < Vs ? 5 : s < Gs ? 6 : s < qs ? 7 : s < Js ? 8 : s < Ws ? 9 : 10;\n},\n    Hs = {\n  encode: Fs,\n  decode: Ms,\n  encodingLength: Xs\n},\n    ge = Hs;\n\nconst pe = function (s, e) {\n  let t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return ge.encode(s, e, t), e;\n},\n      be = s => ge.encodingLength(s),\n      W = (s, e) => {\n  const t = e.byteLength,\n        i = be(s),\n        r = i + be(t),\n        n = new Uint8Array(r + t);\n  return pe(s, n, 0), pe(t, n, i), n.set(e, r), new Zs(s, t, e, n);\n};\n\nclass Zs {\n  constructor(e, t, i, r) {\n    this.code = e, this.size = t, this.digest = i, this.bytes = r;\n  }\n\n}\n\nconst fe = _ref4 => {\n  let {\n    name: s,\n    code: e,\n    encode: t\n  } = _ref4;\n  return new Qs(s, e, t);\n};\n\nclass Qs {\n  constructor(e, t, i) {\n    this.name = e, this.code = t, this.encode = i;\n  }\n\n  digest(e) {\n    if (e instanceof Uint8Array) {\n      const t = this.encode(e);\n      return t instanceof Uint8Array ? W(this.code, t) : t.then(i => W(this.code, i));\n    } else throw Error(\"Unknown type, must be binary type\");\n  }\n\n}\n\nconst ye = s => async e => new Uint8Array(await crypto.subtle.digest(s, e)),\n      ei = fe({\n  name: \"sha2-256\",\n  code: 18,\n  encode: ye(\"SHA-256\")\n}),\n      ti = fe({\n  name: \"sha2-512\",\n  code: 19,\n  encode: ye(\"SHA-512\")\n});\n\nvar si = Object.freeze({\n  __proto__: null,\n  sha256: ei,\n  sha512: ti\n});\n\nconst me = 0,\n      ii = \"identity\",\n      Ee = ue,\n      ri = s => W(me, Ee(s)),\n      ni = {\n  code: me,\n  name: ii,\n  encode: Ee,\n  digest: ri\n};\n\nvar ai = Object.freeze({\n  __proto__: null,\n  identity: ni\n});\nnew TextEncoder(), new TextDecoder();\nconst ve = { ...Zt,\n  ...es,\n  ...ss,\n  ...rs,\n  ...os,\n  ...fs,\n  ...Es,\n  ...Cs,\n  ...Os,\n  ...Ls\n};\n({ ...si,\n  ...ai\n});\n\nfunction oi() {\n  let s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(s) : new Uint8Array(s);\n}\n\nfunction we(s, e, t, i) {\n  return {\n    name: s,\n    prefix: e,\n    encoder: {\n      name: s,\n      prefix: e,\n      encode: t\n    },\n    decoder: {\n      decode: i\n    }\n  };\n}\n\nconst Ce = we(\"utf8\", \"u\", s => {\n  const e = new TextDecoder(\"utf8\");\n  return \"u\" + e.decode(s);\n}, s => new TextEncoder().encode(s.substring(1))),\n      X = we(\"ascii\", \"a\", s => {\n  let e = \"a\";\n\n  for (let t = 0; t < s.length; t++) e += String.fromCharCode(s[t]);\n\n  return e;\n}, s => {\n  s = s.substring(1);\n  const e = oi(s.length);\n\n  for (let t = 0; t < s.length; t++) e[t] = s.charCodeAt(t);\n\n  return e;\n}),\n      ui = {\n  utf8: Ce,\n  \"utf-8\": Ce,\n  hex: ve.base16,\n  latin1: X,\n  ascii: X,\n  binary: X,\n  ...ve\n};\n\nfunction hi(s) {\n  let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"utf8\";\n  const t = ui[e];\n  if (!t) throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(s, \"utf8\") : t.decoder.decode(`${t.prefix}${s}`);\n}\n\nconst H = \"wc\",\n      _e = 2,\n      k = \"core\",\n      z = `${H}@${2}:${k}:`,\n      Se = {\n  name: k,\n  logger: \"error\"\n},\n      Ie = {\n  database: \":memory:\"\n},\n      Ae = \"crypto\",\n      Z = \"client_ed25519_seed\",\n      Oe = At,\n      Re = \"keychain\",\n      Te = \"0.3\",\n      ze = \"messages\",\n      Pe = \"0.3\",\n      xe = Ot,\n      Le = \"publisher\",\n      ci = \"irn\",\n      Fe = \"error\",\n      Ue = \"wss://relay.walletconnect.com\",\n      Ne = \"relayer\",\n      L = {\n  message: \"relayer_message\",\n  connect: \"relayer_connect\",\n  disconnect: \"relayer_disconnect\",\n  error: \"relayer_error\"\n},\n      Be = \"_subscription\",\n      T = {\n  payload: \"payload\",\n  connect: \"connect\",\n  disconnect: \"disconnect\",\n  error: \"error\"\n},\n      Me = Rt,\n      li = {\n  database: \":memory:\"\n},\n      Ke = \"2.0.0-rc.1\",\n      ke = \"0.3\",\n      O = {\n  created: \"subscription_created\",\n  deleted: \"subscription_deleted\",\n  expired: \"subscription_expired\",\n  disabled: \"subscription_disabled\",\n  sync: \"subscription_sync\"\n},\n      Di = Tt,\n      $e = \"subscription\",\n      je = \"0.3\",\n      Ye = zt * 1e3;\n\nclass Ve {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.keychain = new Map(), this.name = Re, this.version = Te, this.initialized = !1, this.storagePrefix = z, this.init = async () => {\n      if (!this.initialized) {\n        const i = await this.getKeyChain();\n        typeof i < \"u\" && (this.keychain = i), this.initialized = !0;\n      }\n    }, this.has = i => (this.isInitialized(), this.keychain.has(i)), this.set = async (i, r) => {\n      this.isInitialized(), this.keychain.set(i, r), await this.persist();\n    }, this.get = i => {\n      this.isInitialized();\n      const r = this.keychain.get(i);\n\n      if (typeof r > \"u\") {\n        const {\n          message: n\n        } = m(\"NO_MATCHING_KEY\", `${this.name}: ${i}`);\n        throw new Error(n);\n      }\n\n      return r;\n    }, this.del = async i => {\n      this.isInitialized(), this.keychain.delete(i), await this.persist();\n    }, this.core = e, this.logger = I(t, this.name);\n  }\n\n  get context() {\n    return A(this.logger);\n  }\n\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n\n  async setKeyChain(e) {\n    await this.core.storage.setItem(this.storageKey, ie(e));\n  }\n\n  async getKeyChain() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? re(e) : void 0;\n  }\n\n  async persist() {\n    await this.setKeyChain(this.keychain);\n  }\n\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = m(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n\n}\n\nclass Ge {\n  constructor(e, t, i) {\n    this.core = e, this.logger = t, this.name = Ae, this.initialized = !1, this.init = async () => {\n      this.initialized || (await this.keychain.init(), this.initialized = !0);\n    }, this.hasKeys = r => (this.isInitialized(), this.keychain.has(r)), this.getClientId = async () => {\n      this.isInitialized();\n      const r = await this.getClientSeed(),\n            n = N.generateKeyPair(r);\n      return N.encodeIss(n.publicKey);\n    }, this.generateKeyPair = () => {\n      this.isInitialized();\n      const r = bt();\n      return this.setPrivateKey(r.publicKey, r.privateKey);\n    }, this.signJWT = async r => {\n      this.isInitialized();\n      const n = await this.getClientSeed(),\n            a = N.generateKeyPair(n),\n            o = ne(),\n            u = Oe;\n      return await N.signJWT(o, r, u, a);\n    }, this.generateSharedKey = (r, n, a) => {\n      this.isInitialized();\n      const o = this.getPrivateKey(r),\n            u = ft(o, n);\n      return this.setSymKey(u, a);\n    }, this.setSymKey = async (r, n) => {\n      this.isInitialized();\n      const a = n || yt(r);\n      return await this.keychain.set(a, r), a;\n    }, this.deleteKeyPair = async r => {\n      this.isInitialized(), await this.keychain.del(r);\n    }, this.deleteSymKey = async r => {\n      this.isInitialized(), await this.keychain.del(r);\n    }, this.encode = async (r, n, a) => {\n      this.isInitialized();\n      const o = mt(a),\n            u = gt(n);\n\n      if (ae(o)) {\n        const F = o.senderPublicKey,\n              Y = o.receiverPublicKey;\n        r = await this.generateSharedKey(F, Y);\n      }\n\n      const p = this.getSymKey(r),\n            {\n        type: c,\n        senderPublicKey: l\n      } = o;\n      return Et({\n        type: c,\n        symKey: p,\n        message: u,\n        senderPublicKey: l\n      });\n    }, this.decode = async (r, n, a) => {\n      this.isInitialized();\n      const o = vt(n, a);\n\n      if (ae(o)) {\n        const c = o.receiverPublicKey,\n              l = o.senderPublicKey;\n        r = await this.generateSharedKey(c, l);\n      }\n\n      const u = this.getSymKey(r),\n            p = wt({\n        symKey: u,\n        encoded: n\n      });\n      return pt(p);\n    }, this.core = e, this.logger = I(t, this.name), this.keychain = i || new Ve(this.core, this.logger);\n  }\n\n  get context() {\n    return A(this.logger);\n  }\n\n  async setPrivateKey(e, t) {\n    return await this.keychain.set(e, t), e;\n  }\n\n  getPrivateKey(e) {\n    return this.keychain.get(e);\n  }\n\n  async getClientSeed() {\n    let e = \"\";\n\n    try {\n      e = this.keychain.get(Z);\n    } catch {\n      e = ne(), await this.keychain.set(Z, e);\n    }\n\n    return hi(e, \"base16\");\n  }\n\n  getSymKey(e) {\n    return this.keychain.get(e);\n  }\n\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = m(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n\n}\n\nclass qe extends ut {\n  constructor(e, t) {\n    super(e, t), this.logger = e, this.core = t, this.messages = new Map(), this.name = ze, this.version = Pe, this.initialized = !1, this.storagePrefix = z, this.init = async () => {\n      if (!this.initialized) {\n        this.logger.trace(\"Initialized\");\n\n        try {\n          const i = await this.getRelayerMessages();\n          typeof i < \"u\" && (this.messages = i), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({\n            type: \"method\",\n            method: \"restore\",\n            size: this.messages.size\n          });\n        } catch (i) {\n          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i);\n        } finally {\n          this.initialized = !0;\n        }\n      }\n    }, this.set = async (i, r) => {\n      this.isInitialized();\n      const n = B(r);\n      let a = this.messages.get(i);\n      return typeof a > \"u\" && (a = {}), typeof a[n] < \"u\" || (a[n] = r, this.messages.set(i, a), await this.persist()), n;\n    }, this.get = i => {\n      this.isInitialized();\n      let r = this.messages.get(i);\n      return typeof r > \"u\" && (r = {}), r;\n    }, this.has = (i, r) => {\n      this.isInitialized();\n      const n = this.get(i),\n            a = B(r);\n      return typeof n[a] < \"u\";\n    }, this.del = async i => {\n      this.isInitialized(), this.messages.delete(i), await this.persist();\n    }, this.logger = I(e, this.name), this.core = t;\n  }\n\n  get context() {\n    return A(this.logger);\n  }\n\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n\n  async setRelayerMessages(e) {\n    await this.core.storage.setItem(this.storageKey, ie(e));\n  }\n\n  async getRelayerMessages() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? re(e) : void 0;\n  }\n\n  async persist() {\n    await this.setRelayerMessages(this.messages);\n  }\n\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = m(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n\n}\n\nclass di extends ht {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.events = new M.EventEmitter(), this.name = Le, this.queue = new Map(), this.publish = async (i, r, n) => {\n      this.logger.debug(\"Publishing Payload\"), this.logger.trace({\n        type: \"method\",\n        method: \"publish\",\n        params: {\n          topic: i,\n          message: r,\n          opts: n\n        }\n      });\n\n      try {\n        const a = n?.ttl || xe,\n              o = V(n),\n              u = n?.prompt || !1,\n              p = n?.tag || 0,\n              c = {\n          topic: i,\n          message: r,\n          opts: {\n            ttl: a,\n            relay: o,\n            prompt: u,\n            tag: p\n          }\n        },\n              l = B(r);\n        this.queue.set(l, c), await this.rpcPublish(i, r, a, o, u, p), this.onPublish(l, c), this.logger.debug(\"Successfully Published Payload\"), this.logger.trace({\n          type: \"method\",\n          method: \"publish\",\n          params: {\n            topic: i,\n            message: r,\n            opts: n\n          }\n        });\n      } catch (a) {\n        throw this.logger.debug(\"Failed to Publish Payload\"), this.logger.error(a), a;\n      }\n    }, this.on = (i, r) => {\n      this.events.on(i, r);\n    }, this.once = (i, r) => {\n      this.events.once(i, r);\n    }, this.off = (i, r) => {\n      this.events.off(i, r);\n    }, this.removeListener = (i, r) => {\n      this.events.removeListener(i, r);\n    }, this.relayer = e, this.logger = I(t, this.name), this.registerEventListeners();\n  }\n\n  get context() {\n    return A(this.logger);\n  }\n\n  rpcPublish(e, t, i, r, n, a) {\n    var o, u, p, c;\n    const l = {\n      method: G(r.protocol).publish,\n      params: {\n        topic: e,\n        message: t,\n        ttl: i,\n        prompt: n,\n        tag: a\n      }\n    };\n    return q((o = l.params) == null ? void 0 : o.prompt) && ((u = l.params) == null || delete u.prompt), q((p = l.params) == null ? void 0 : p.tag) && ((c = l.params) == null || delete c.tag), this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"message\",\n      direction: \"outgoing\",\n      request: l\n    }), this.relayer.provider.request(l);\n  }\n\n  onPublish(e, t) {\n    this.queue.delete(e);\n  }\n\n  checkQueue() {\n    this.queue.forEach(async e => {\n      const {\n        topic: t,\n        message: i,\n        opts: {\n          ttl: r,\n          relay: n,\n          prompt: a,\n          tag: o\n        }\n      } = e,\n            u = B(i);\n      await this.rpcPublish(t, i, r, n, a, o), this.onPublish(u, e);\n    });\n  }\n\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(te.pulse, () => {\n      this.checkQueue();\n    });\n  }\n\n}\n\nclass gi {\n  constructor() {\n    this.map = new Map(), this.set = (e, t) => {\n      const i = this.get(e);\n      this.exists(e, t) || this.map.set(e, [...i, t]);\n    }, this.get = e => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {\n      if (typeof t > \"u\") {\n        this.map.delete(e);\n        return;\n      }\n\n      if (!this.map.has(e)) return;\n      const i = this.get(e);\n      if (!this.exists(e, t)) return;\n      const r = i.filter(n => n !== t);\n\n      if (!r.length) {\n        this.map.delete(e);\n        return;\n      }\n\n      this.map.set(e, r);\n    }, this.clear = () => {\n      this.map.clear();\n    };\n  }\n\n  get topics() {\n    return Array.from(this.map.keys());\n  }\n\n}\n\nvar pi = Object.defineProperty,\n    bi = Object.defineProperties,\n    fi = Object.getOwnPropertyDescriptors,\n    Je = Object.getOwnPropertySymbols,\n    yi = Object.prototype.hasOwnProperty,\n    mi = Object.prototype.propertyIsEnumerable,\n    We = (s, e, t) => e in s ? pi(s, e, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: t\n}) : s[e] = t,\n    $ = (s, e) => {\n  for (var t in e || (e = {})) yi.call(e, t) && We(s, t, e[t]);\n\n  if (Je) for (var t of Je(e)) mi.call(e, t) && We(s, t, e[t]);\n  return s;\n},\n    Q = (s, e) => bi(s, fi(e));\n\nclass Xe extends ct {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = new Map(), this.topicMap = new gi(), this.events = new M.EventEmitter(), this.name = $e, this.version = je, this.pending = new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = \"pending_sub_watch_label\", this.pendingSubInterval = 20, this.storagePrefix = z, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), await this.reset(), this.registerEventListeners(), this.onEnable());\n    }, this.subscribe = async (i, r) => {\n      this.isInitialized(), this.logger.debug(\"Subscribing Topic\"), this.logger.trace({\n        type: \"method\",\n        method: \"subscribe\",\n        params: {\n          topic: i,\n          opts: r\n        }\n      });\n\n      try {\n        const n = V(r),\n              a = {\n          topic: i,\n          relay: n\n        };\n        this.pending.set(i, a);\n        const o = await this.rpcSubscribe(i, n);\n        return this.onSubscribe(o, a), this.logger.debug(\"Successfully Subscribed Topic\"), this.logger.trace({\n          type: \"method\",\n          method: \"subscribe\",\n          params: {\n            topic: i,\n            opts: r\n          }\n        }), o;\n      } catch (n) {\n        throw this.logger.debug(\"Failed to Subscribe Topic\"), this.logger.error(n), n;\n      }\n    }, this.unsubscribe = async (i, r) => {\n      this.isInitialized(), typeof r?.id < \"u\" ? await this.unsubscribeById(i, r.id, r) : await this.unsubscribeByTopic(i, r);\n    }, this.isSubscribed = async i => this.topics.includes(i) ? !0 : await new Promise((r, n) => {\n      const a = new Pt();\n      a.start(this.pendingSubscriptionWatchLabel);\n      const o = setInterval(() => {\n        !this.pending.has(i) && this.topics.includes(i) && (clearInterval(o), a.stop(this.pendingSubscriptionWatchLabel), r(!0)), a.elapsed(this.pendingSubscriptionWatchLabel) >= Ye && (clearInterval(o), a.stop(this.pendingSubscriptionWatchLabel), n(!1));\n      }, this.pendingSubInterval);\n    }), this.on = (i, r) => {\n      this.events.on(i, r);\n    }, this.once = (i, r) => {\n      this.events.once(i, r);\n    }, this.off = (i, r) => {\n      this.events.off(i, r);\n    }, this.removeListener = (i, r) => {\n      this.events.removeListener(i, r);\n    }, this.relayer = e, this.logger = I(t, this.name);\n  }\n\n  get context() {\n    return A(this.logger);\n  }\n\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n\n  get length() {\n    return this.subscriptions.size;\n  }\n\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n\n  get topics() {\n    return this.topicMap.topics;\n  }\n\n  hasSubscription(e, t) {\n    let i = !1;\n\n    try {\n      i = this.getSubscription(e).topic === t;\n    } catch {}\n\n    return i;\n  }\n\n  onEnable() {\n    this.cached = [], this.initialized = !0;\n  }\n\n  onDisable() {\n    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear(), this.initialized = !1;\n  }\n\n  async unsubscribeByTopic(e, t) {\n    const i = this.topicMap.get(e);\n    await Promise.all(i.map(async r => await this.unsubscribeById(e, r, t)));\n  }\n\n  async unsubscribeById(e, t, i) {\n    this.logger.debug(\"Unsubscribing Topic\"), this.logger.trace({\n      type: \"method\",\n      method: \"unsubscribe\",\n      params: {\n        topic: e,\n        id: t,\n        opts: i\n      }\n    });\n\n    try {\n      const r = V(i);\n      await this.rpcUnsubscribe(e, t, r);\n      const n = Ct(\"USER_DISCONNECTED\", `${this.name}, ${e}`);\n      await this.onUnsubscribe(e, t, n), this.logger.debug(\"Successfully Unsubscribed Topic\"), this.logger.trace({\n        type: \"method\",\n        method: \"unsubscribe\",\n        params: {\n          topic: e,\n          id: t,\n          opts: i\n        }\n      });\n    } catch (r) {\n      throw this.logger.debug(\"Failed to Unsubscribe Topic\"), this.logger.error(r), r;\n    }\n  }\n\n  async rpcSubscribe(e, t) {\n    const i = {\n      method: G(t.protocol).subscribe,\n      params: {\n        topic: e\n      }\n    };\n    return this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: i\n    }), await this.relayer.provider.request(i);\n  }\n\n  rpcUnsubscribe(e, t, i) {\n    const r = {\n      method: G(i.protocol).unsubscribe,\n      params: {\n        topic: e,\n        id: t\n      }\n    };\n    return this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: r\n    }), this.relayer.provider.request(r);\n  }\n\n  onSubscribe(e, t) {\n    this.setSubscription(e, Q($({}, t), {\n      id: e\n    })), this.pending.delete(t.topic);\n  }\n\n  onResubscribe(e, t) {\n    this.addSubscription(e, Q($({}, t), {\n      id: e\n    })), this.pending.delete(t.topic);\n  }\n\n  async onUnsubscribe(e, t, i) {\n    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i), await this.relayer.messages.del(e);\n  }\n\n  async setRelayerSubscriptions(e) {\n    await this.relayer.core.storage.setItem(this.storageKey, e);\n  }\n\n  async getRelayerSubscriptions() {\n    return await this.relayer.core.storage.getItem(this.storageKey);\n  }\n\n  setSubscription(e, t) {\n    this.subscriptions.has(e) || (this.logger.debug(\"Setting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"setSubscription\",\n      id: e,\n      subscription: t\n    }), this.addSubscription(e, t));\n  }\n\n  addSubscription(e, t) {\n    this.subscriptions.set(e, $({}, t)), this.topicMap.set(t.topic, e), this.events.emit(O.created, t);\n  }\n\n  getSubscription(e) {\n    this.logger.debug(\"Getting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"getSubscription\",\n      id: e\n    });\n    const t = this.subscriptions.get(e);\n\n    if (!t) {\n      const {\n        message: i\n      } = m(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(i);\n    }\n\n    return t;\n  }\n\n  deleteSubscription(e, t) {\n    this.logger.debug(\"Deleting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"deleteSubscription\",\n      id: e,\n      reason: t\n    });\n    const i = this.getSubscription(e);\n    this.subscriptions.delete(e), this.topicMap.delete(i.topic, e), this.events.emit(O.deleted, Q($({}, i), {\n      reason: t\n    }));\n  }\n\n  async persist() {\n    await this.setRelayerSubscriptions(this.values), this.events.emit(O.sync);\n  }\n\n  async reset() {\n    !this.cached.length || (await Promise.all(this.cached.map(async e => await this.resubscribe(e))));\n  }\n\n  async restore() {\n    try {\n      const e = await this.getRelayerSubscriptions();\n      if (typeof e > \"u\" || !e.length) return;\n\n      if (this.subscriptions.size) {\n        const {\n          message: t\n        } = m(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n\n      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        subscriptions: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);\n    }\n  }\n\n  async resubscribe(e) {\n    if (!this.ids.includes(e.id)) {\n      const {\n        topic: t,\n        relay: i\n      } = e,\n            r = {\n        topic: t,\n        relay: i\n      };\n      this.pending.set(r.topic, r);\n      const n = await this.rpcSubscribe(r.topic, r.relay);\n      this.onResubscribe(n, r);\n    }\n  }\n\n  async onConnect() {\n    await this.reset(), this.onEnable();\n  }\n\n  onDisconnect() {\n    this.onDisable();\n  }\n\n  checkPending() {\n    this.pending.forEach(async e => {\n      const t = await this.rpcSubscribe(e.topic, e.relay);\n      this.onSubscribe(t, e);\n    });\n  }\n\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(te.pulse, () => {\n      this.checkPending();\n    }), this.relayer.provider.on(T.connect, async () => {\n      await this.onConnect();\n    }), this.relayer.provider.on(T.disconnect, () => {\n      this.onDisconnect();\n    }), this.events.on(O.created, async e => {\n      const t = O.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), await this.persist();\n    }), this.events.on(O.deleted, async e => {\n      const t = O.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), await this.persist();\n    });\n  }\n\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = m(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n\n}\n\nvar Ei = Object.defineProperty,\n    He = Object.getOwnPropertySymbols,\n    vi = Object.prototype.hasOwnProperty,\n    wi = Object.prototype.propertyIsEnumerable,\n    Ze = (s, e, t) => e in s ? Ei(s, e, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: t\n}) : s[e] = t,\n    Ci = (s, e) => {\n  for (var t in e || (e = {})) vi.call(e, t) && Ze(s, t, e[t]);\n\n  if (He) for (var t of He(e)) wi.call(e, t) && Ze(s, t, e[t]);\n  return s;\n};\n\nclass Qe extends lt {\n  constructor(e) {\n    super(e), this.protocol = \"wc\", this.version = 2, this.events = new M.EventEmitter(), this.name = Ne, this.initialized = !1, this.core = e.core, this.logger = typeof e.logger < \"u\" && typeof e.logger != \"string\" ? I(e.logger, this.name) : ee(se({\n      level: e.logger || Fe\n    })), this.messages = new qe(this.logger, e.core), this.subscriber = new Xe(this, this.logger), this.publisher = new di(this, this.logger), this.relayUrl = e?.relayUrl || Ue, this.projectId = e.projectId, this.provider = {};\n  }\n\n  async init() {\n    this.logger.trace(\"Initialized\");\n    const e = await this.core.crypto.signJWT(this.relayUrl);\n    this.provider = this.createProvider(e), await Promise.all([this.messages.init(), this.provider.connect(), this.subscriber.init()]), this.registerEventListeners(), this.initialized = !0;\n  }\n\n  get context() {\n    return A(this.logger);\n  }\n\n  get connected() {\n    return this.provider.connection.connected;\n  }\n\n  get connecting() {\n    return this.provider.connection.connecting;\n  }\n\n  async publish(e, t, i) {\n    this.isInitialized(), await this.publisher.publish(e, t, i), await this.recordMessageEvent({\n      topic: e,\n      message: t\n    });\n  }\n\n  async subscribe(e, t) {\n    return this.isInitialized(), await this.subscriber.subscribe(e, t);\n  }\n\n  async unsubscribe(e, t) {\n    this.isInitialized(), await this.subscriber.unsubscribe(e, t);\n  }\n\n  on(e, t) {\n    this.events.on(e, t);\n  }\n\n  once(e, t) {\n    this.events.once(e, t);\n  }\n\n  off(e, t) {\n    this.events.off(e, t);\n  }\n\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n\n  createProvider(e) {\n    return new Lt(new Nt(_t({\n      sdkVersion: Ke,\n      protocol: this.protocol,\n      version: this.version,\n      relayUrl: this.relayUrl,\n      projectId: this.projectId,\n      auth: e\n    })));\n  }\n\n  async recordMessageEvent(e) {\n    const {\n      topic: t,\n      message: i\n    } = e;\n    await this.messages.set(t, i);\n  }\n\n  async shouldIgnoreMessageEvent(e) {\n    const {\n      topic: t,\n      message: i\n    } = e;\n    return (await this.subscriber.isSubscribed(t)) ? this.messages.has(t, i) : !0;\n  }\n\n  async onProviderPayload(e) {\n    if (this.logger.debug(\"Incoming Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"incoming\",\n      payload: e\n    }), Ft(e)) {\n      if (!e.method.endsWith(Be)) return;\n      const t = e.params,\n            {\n        topic: i,\n        message: r\n      } = t.data,\n            n = {\n        topic: i,\n        message: r\n      };\n      this.logger.debug(\"Emitting Relayer Payload\"), this.logger.trace(Ci({\n        type: \"event\",\n        event: t.id\n      }, n)), this.events.emit(t.id, n), await this.acknowledgePayload(e), await this.onMessageEvent(n);\n    }\n  }\n\n  async onMessageEvent(e) {\n    (await this.shouldIgnoreMessageEvent(e)) || (this.events.emit(L.message, e), await this.recordMessageEvent(e));\n  }\n\n  async acknowledgePayload(e) {\n    const t = Ut(e.id, !0);\n    await this.provider.connection.send(t);\n  }\n\n  registerEventListeners() {\n    this.provider.on(T.payload, e => this.onProviderPayload(e)), this.provider.on(T.connect, () => {\n      this.events.emit(L.connect);\n    }), this.provider.on(T.disconnect, () => {\n      this.events.emit(L.disconnect), setTimeout(() => {\n        this.provider.connect();\n      }, xt(Me));\n    }), this.provider.on(T.error, e => this.events.emit(L.error, e));\n  }\n\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = m(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n\n}\n\nvar _i = Object.defineProperty,\n    et = Object.getOwnPropertySymbols,\n    Si = Object.prototype.hasOwnProperty,\n    Ii = Object.prototype.propertyIsEnumerable,\n    tt = (s, e, t) => e in s ? _i(s, e, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: t\n}) : s[e] = t,\n    st = (s, e) => {\n  for (var t in e || (e = {})) Si.call(e, t) && tt(s, t, e[t]);\n\n  if (et) for (var t of et(e)) Ii.call(e, t) && tt(s, t, e[t]);\n  return s;\n};\n\nclass Ai extends Dt {\n  constructor(e, t, i) {\n    let r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : z;\n    let n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : void 0;\n    super(e, t, i, r), this.core = e, this.logger = t, this.name = i, this.map = new Map(), this.version = ke, this.cached = [], this.initialized = !1, this.storagePrefix = z, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach(a => {\n        St(a) ? this.map.set(a.id, a) : It(a) ? this.map.set(a.topic, a) : this.getKey && a !== null && !q(a) && this.map.set(this.getKey(a), a);\n      }), this.cached = [], this.initialized = !0);\n    }, this.set = async (a, o) => {\n      this.isInitialized(), this.map.has(a) ? await this.update(a, o) : (this.logger.debug(\"Setting value\"), this.logger.trace({\n        type: \"method\",\n        method: \"set\",\n        key: a,\n        value: o\n      }), this.map.set(a, o), await this.persist());\n    }, this.get = a => (this.isInitialized(), this.logger.debug(\"Getting value\"), this.logger.trace({\n      type: \"method\",\n      method: \"get\",\n      key: a\n    }), this.getData(a)), this.getAll = a => a ? this.values.filter(o => Object.keys(a).every(u => Bt(o[u], a[u]))) : this.values, this.update = async (a, o) => {\n      this.isInitialized(), this.logger.debug(\"Updating value\"), this.logger.trace({\n        type: \"method\",\n        method: \"update\",\n        key: a,\n        update: o\n      });\n      const u = st(st({}, this.getData(a)), o);\n      this.map.set(a, u), await this.persist();\n    }, this.delete = async (a, o) => {\n      this.isInitialized(), this.map.has(a) && (this.logger.debug(\"Deleting value\"), this.logger.trace({\n        type: \"method\",\n        method: \"delete\",\n        key: a,\n        reason: o\n      }), this.map.delete(a), await this.persist());\n    }, this.logger = I(t, this.name), this.storagePrefix = r, this.getKey = n;\n  }\n\n  get context() {\n    return A(this.logger);\n  }\n\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n\n  get length() {\n    return this.map.size;\n  }\n\n  get keys() {\n    return Array.from(this.map.keys());\n  }\n\n  get values() {\n    return Array.from(this.map.values());\n  }\n\n  async setDataStore(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n\n  async getDataStore() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n\n  getData(e) {\n    const t = this.map.get(e);\n\n    if (!t) {\n      const {\n        message: i\n      } = m(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.error(i), new Error(i);\n    }\n\n    return t;\n  }\n\n  async persist() {\n    await this.setDataStore(this.values);\n  }\n\n  async restore() {\n    try {\n      const e = await this.getDataStore();\n      if (typeof e > \"u\" || !e.length) return;\n\n      if (this.map.size) {\n        const {\n          message: t\n        } = m(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n\n      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        value: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);\n    }\n  }\n\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = m(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n\n}\n\nvar Oi = Object.defineProperty,\n    it = Object.getOwnPropertySymbols,\n    Ri = Object.prototype.hasOwnProperty,\n    Ti = Object.prototype.propertyIsEnumerable,\n    rt = (s, e, t) => e in s ? Oi(s, e, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: t\n}) : s[e] = t,\n    nt = (s, e) => {\n  for (var t in e || (e = {})) Ri.call(e, t) && rt(s, t, e[t]);\n\n  if (it) for (var t of it(e)) Ti.call(e, t) && rt(s, t, e[t]);\n  return s;\n};\n\nclass j extends dt {\n  constructor(e) {\n    super(e), this.protocol = H, this.version = _e, this.name = k, this.events = new M.EventEmitter(), this.initialized = !1, this.on = (i, r) => this.events.on(i, r), this.once = (i, r) => this.events.once(i, r), this.off = (i, r) => this.events.off(i, r), this.removeListener = (i, r) => this.events.removeListener(i, r), this.projectId = e?.projectId;\n    const t = typeof e?.logger < \"u\" && typeof e?.logger != \"string\" ? e.logger : ee(se({\n      level: e?.logger || Se.logger\n    }));\n    this.logger = I(t, this.name), this.heartbeat = new ot(), this.crypto = new Ge(this, this.logger, e?.keychain), this.storage = e != null && e.storage ? e.storage : new at(nt(nt({}, Ie), e?.storageOptions)), this.relayer = new Qe({\n      core: this,\n      logger: this.logger,\n      relayUrl: e?.relayUrl,\n      projectId: this.projectId\n    });\n  }\n\n  static async init(e) {\n    const t = new j(e);\n    return await t.initialize(), t;\n  }\n\n  get context() {\n    return A(this.logger);\n  }\n\n  async start() {\n    this.initialized || (await this.initialize());\n  }\n\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n\n    try {\n      await this.crypto.init(), await this.relayer.init(), await this.heartbeat.init(), this.initialized = !0, this.logger.info(\"Core Initilization Success\");\n    } catch (e) {\n      throw this.logger.info(\"Core Initilization Failure\"), this.logger.error(e.message), e;\n    }\n  }\n\n}\n\nconst zi = j;\nexport { k as CORE_CONTEXT, Se as CORE_DEFAULT, H as CORE_PROTOCOL, Ie as CORE_STORAGE_OPTIONS, z as CORE_STORAGE_PREFIX, _e as CORE_VERSION, Z as CRYPTO_CLIENT_SEED, Ae as CRYPTO_CONTEXT, Oe as CRYPTO_JWT_TTL, zi as Core, Ge as Crypto, Re as KEYCHAIN_CONTEXT, Te as KEYCHAIN_STORAGE_VERSION, Ve as KeyChain, ze as MESSAGES_CONTEXT, Pe as MESSAGES_STORAGE_VERSION, qe as MessageTracker, Ye as PENDING_SUB_RESOLUTION_TIMEOUT, Le as PUBLISHER_CONTEXT, xe as PUBLISHER_DEFAULT_TTL, Ne as RELAYER_CONTEXT, Fe as RELAYER_DEFAULT_LOGGER, ci as RELAYER_DEFAULT_PROTOCOL, Ue as RELAYER_DEFAULT_RELAY_URL, L as RELAYER_EVENTS, T as RELAYER_PROVIDER_EVENTS, Me as RELAYER_RECONNECT_TIMEOUT, Ke as RELAYER_SDK_VERSION, li as RELAYER_STORAGE_OPTIONS, Be as RELAYER_SUBSCRIBER_SUFFIX, Qe as Relayer, ke as STORE_STORAGE_VERSION, $e as SUBSCRIBER_CONTEXT, Di as SUBSCRIBER_DEFAULT_TTL, O as SUBSCRIBER_EVENTS, je as SUBSCRIBER_STORAGE_VERSION, Ai as Store, Xe as Subscriber, j as default }; //# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module"}