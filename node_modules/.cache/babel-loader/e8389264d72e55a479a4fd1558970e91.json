{"ast":null,"code":"const U32_MASK64 = BigInt(2 ** 32 - 1);\n\nconst _32n = BigInt(32); // We are not using BigUint64Array, because they are extremely slow as per 2022\n\n\nexport function fromBig(n) {\n  let le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (le) return {\n    h: Number(n & U32_MASK64),\n    l: Number(n >> _32n & U32_MASK64)\n  };\n  return {\n    h: Number(n >> _32n & U32_MASK64) | 0,\n    l: Number(n & U32_MASK64) | 0\n  };\n}\nexport function split(lst) {\n  let le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n\n  for (let i = 0; i < lst.length; i++) {\n    const {\n      h,\n      l\n    } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n\n  return [Ah, Al];\n}\nexport const toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0); // for Shift in [0, 32)\n\nconst shrSH = (h, l, s) => h >>> s;\n\nconst shrSL = (h, l, s) => h << 32 - s | l >>> s; // Right rotate for Shift in [1, 32)\n\n\nconst rotrSH = (h, l, s) => h >>> s | l << 32 - s;\n\nconst rotrSL = (h, l, s) => h << 32 - s | l >>> s; // Right rotate for Shift in (32, 64), NOTE: 32 is special case.\n\n\nconst rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;\n\nconst rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s; // Right rotate for shift===32 (just swaps l&h)\n\n\nconst rotr32H = (h, l) => l;\n\nconst rotr32L = (h, l) => h; // Left rotate for Shift in [1, 32)\n\n\nconst rotlSH = (h, l, s) => h << s | l >>> 32 - s;\n\nconst rotlSL = (h, l, s) => l << s | h >>> 32 - s; // Left rotate for Shift in (32, 64), NOTE: 32 is special case.\n\n\nconst rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;\n\nconst rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s; // JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\n// Removing \"export\" has 5% perf penalty -_-\n\n\nexport function add(Ah, Al, Bh, Bl) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return {\n    h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n    l: l | 0\n  };\n} // Addition with more than 2 elements\n\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\n\nconst add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\n\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\n\nconst add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\n\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\n\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0; // prettier-ignore\n\n\nconst u64 = {\n  fromBig,\n  split,\n  toBig,\n  shrSH,\n  shrSL,\n  rotrSH,\n  rotrSL,\n  rotrBH,\n  rotrBL,\n  rotr32H,\n  rotr32L,\n  rotlSH,\n  rotlSL,\n  rotlBH,\n  rotlBL,\n  add,\n  add3L,\n  add3H,\n  add4L,\n  add4H,\n  add5H,\n  add5L\n};\nexport default u64;","map":null,"metadata":{},"sourceType":"module"}