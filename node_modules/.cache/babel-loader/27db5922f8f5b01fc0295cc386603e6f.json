{"ast":null,"code":"/* global module */\n\n/**\n * Library for sampling of random values from a discrete probability distribution, \n * using the Walker-Vose alias method.\n *\n * Creates a new Sample instance for the given probabilities and outcomes.\n *\n * @param {Array} the probabilities.\n * @param {Array} the outcomes. Index is assumed as outcome if not provided.\n */\nfunction Sample(probabilities, outcomes, rng) {\n  'use strict';\n\n  this.alias = [];\n  this.prob = [];\n  this.outcomes = outcomes || this.indexedOutcomes(probabilities.length);\n  this.rng = rng || Math.random;\n  this.precomputeAlias(probabilities);\n}\n/**\n * Samples outcomes from the underlying probability distribution.\n *\n * @param {int} the number of samples. Optional parameter, defaults to 1.\n * @return {Object} a random outcome according to the underlying probability distribution \n *                  and the requested number of samples. If the requested number of samples \n *                  is greater than 1 this method returns an array.\n */\n\n\nSample.prototype.next = function (numOfSamples) {\n  'use strict';\n\n  var n = numOfSamples || 1,\n      out = [],\n      i = 0;\n\n  do {\n    var c = Math.floor(this.rng() * this.prob.length);\n    out[i] = this.outcomes[this.rng() < this.prob[c] ? c : this.alias[c]];\n  } while (++i < n);\n\n  return n > 1 ? out : out[0];\n};\n/**\n * Ported from ransampl.c\n * Scientific Computing Group of JCNS at MLZ Garching.\n * http://apps.jcns.fz-juelich.de/doku/sc/ransampl\n */\n\n\nSample.prototype.precomputeAlias = function (p) {\n  'use strict';\n\n  var n = p.length,\n      sum = 0,\n      nS = 0,\n      nL = 0,\n      P = [],\n      S = [],\n      L = [],\n      g,\n      i,\n      a; // Normalize probabilities\n\n  for (i = 0; i < n; ++i) {\n    if (p[i] < 0) {\n      throw 'Probability must be a positive: p[' + i + ']=' + p[i];\n    }\n\n    sum += p[i];\n  }\n\n  if (sum === 0) {\n    throw 'Probability cannot be zero.';\n  }\n\n  for (i = 0; i < n; ++i) {\n    P[i] = p[i] * n / sum;\n  } // Set separate index lists for small and large probabilities:\n\n\n  for (i = n - 1; i >= 0; --i) {\n    // at variance from Schwarz, we revert the index order\n    if (P[i] < 1) S[nS++] = i;else L[nL++] = i;\n  } // Work through index lists\n\n\n  while (nS && nL) {\n    a = S[--nS]; // Schwarz's l\n\n    g = L[--nL]; // Schwarz's g\n\n    this.prob[a] = P[a];\n    this.alias[a] = g;\n    P[g] = P[g] + P[a] - 1;\n    if (P[g] < 1) S[nS++] = g;else L[nL++] = g;\n  }\n\n  while (nL) this.prob[L[--nL]] = 1;\n\n  while (nS) // can only happen through numeric instability\n  this.prob[S[--nS]] = 1;\n};\n\nSample.prototype.indexedOutcomes = function (n) {\n  'use strict';\n\n  var o = [];\n\n  for (var i = 0; i < n; i++) o[i] = i;\n\n  return o;\n};\n\nSample.prototype.randomInt = function (min, max) {\n  'use strict';\n\n  return Math.floor(this.rng() * (max - min)) + min;\n};\n\nmodule.exports = function (probabilities, outcomes, rng) {\n  'use strict';\n\n  return new Sample(probabilities, outcomes, rng);\n};","map":null,"metadata":{},"sourceType":"script"}