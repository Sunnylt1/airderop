{"ast":null,"code":"import { ChaCha20Poly1305 as te } from \"@stablelib/chacha20poly1305\";\nimport { HKDF as We } from \"@stablelib/hkdf\";\nimport { randomBytes as re } from \"@stablelib/random\";\nimport { SHA256 as Qe, hash as oe } from \"@stablelib/sha256\";\nimport * as se from \"@stablelib/x25519\";\nimport { toString as f, fromString as p, concat as ie } from \"uint8arrays\";\nimport { detect as Ze } from \"detect-browser\";\nimport { fromMiliseconds as ce, toMiliseconds as V, FIVE_MINUTES as Xe } from \"@walletconnect/time\";\nimport { getDocument as en, getNavigator as ae, getLocation as ue } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata as nn } from \"@walletconnect/window-metadata\";\nimport * as U from \"query-string\";\nimport { RELAY_JSONRPC as tn } from \"@walletconnect/relay-api\";\nconst A = \":\";\n\nfunction de(e) {\n  const [n, t] = e.split(A);\n  return {\n    namespace: n,\n    reference: t\n  };\n}\n\nfunction le(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = e;\n  return [n, t].join(A);\n}\n\nfunction M(e) {\n  const [n, t, r] = e.split(A);\n  return {\n    namespace: n,\n    reference: t,\n    address: r\n  };\n}\n\nfunction fe(e) {\n  const {\n    namespace: n,\n    reference: t,\n    address: r\n  } = e;\n  return [n, t, r].join(A);\n}\n\nfunction K(e, n) {\n  const t = [];\n  return e.forEach(r => {\n    const o = n(r);\n    t.includes(o) || t.push(o);\n  }), t;\n}\n\nfunction pe(e) {\n  const {\n    address: n\n  } = M(e);\n  return n;\n}\n\nfunction me(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = M(e);\n  return le({\n    namespace: n,\n    reference: t\n  });\n}\n\nfunction rn(e, n) {\n  const {\n    namespace: t,\n    reference: r\n  } = de(n);\n  return fe({\n    namespace: t,\n    reference: r,\n    address: e\n  });\n}\n\nfunction on(e) {\n  return K(e, pe);\n}\n\nfunction ye(e) {\n  return K(e, me);\n}\n\nfunction sn(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...o.accounts);\n  }), t;\n}\n\nfunction cn(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...ye(o.accounts));\n  }), t;\n}\n\nfunction an(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...o.chains);\n  }), t;\n}\n\nconst k = \"base10\",\n      a = \"base16\",\n      R = \"base64pad\",\n      C = \"utf8\",\n      L = 0,\n      O = 1,\n      un = 0,\n      Ee = 1,\n      F = 12,\n      H = 32;\n\nfunction dn() {\n  const e = se.generateKeyPair();\n  return {\n    privateKey: f(e.secretKey, a),\n    publicKey: f(e.publicKey, a)\n  };\n}\n\nfunction ln() {\n  const e = re(H);\n  return f(e, a);\n}\n\nfunction fn(e, n) {\n  const t = se.sharedKey(p(e, a), p(n, a)),\n        r = new We(Qe, t).expand(H);\n  return f(r, a);\n}\n\nfunction pn(e) {\n  const n = oe(p(e, a));\n  return f(n, a);\n}\n\nfunction mn(e) {\n  const n = oe(p(e, C));\n  return f(n, a);\n}\n\nfunction he(e) {\n  return p(`${e}`, k);\n}\n\nfunction T(e) {\n  return Number(f(e, k));\n}\n\nfunction yn(e) {\n  const n = he(typeof e.type < \"u\" ? e.type : L);\n  if (T(n) === O && typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n  const t = typeof e.senderPublicKey < \"u\" ? p(e.senderPublicKey, a) : void 0,\n        r = typeof e.iv < \"u\" ? p(e.iv, a) : re(F),\n        o = new te(p(e.symKey, a)).seal(r, p(e.message, C));\n  return Ne({\n    type: n,\n    sealed: o,\n    iv: r,\n    senderPublicKey: t\n  });\n}\n\nfunction En(e) {\n  const n = new te(p(e.symKey, a)),\n        {\n    sealed: t,\n    iv: r\n  } = q(e.encoded),\n        o = n.open(r, t);\n  if (o === null) throw new Error(\"Failed to decrypt\");\n  return f(o, C);\n}\n\nfunction Ne(e) {\n  if (T(e.type) === O) {\n    if (typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n    return f(ie([e.type, e.senderPublicKey, e.iv, e.sealed]), R);\n  }\n\n  return f(ie([e.type, e.iv, e.sealed]), R);\n}\n\nfunction q(e) {\n  const n = p(e, R),\n        t = n.slice(un, Ee),\n        r = Ee;\n\n  if (T(t) === O) {\n    const c = r + H,\n          l = c + F,\n          h = n.slice(r, c),\n          g = n.slice(c, l),\n          P = n.slice(l);\n    return {\n      type: t,\n      sealed: P,\n      iv: g,\n      senderPublicKey: h\n    };\n  }\n\n  const o = r + F,\n        i = n.slice(r, o),\n        s = n.slice(o);\n  return {\n    type: t,\n    sealed: s,\n    iv: i\n  };\n}\n\nfunction hn(e, n) {\n  const t = q(e);\n  return ge({\n    type: T(t.type),\n    senderPublicKey: typeof t.senderPublicKey < \"u\" ? f(t.senderPublicKey, a) : void 0,\n    receiverPublicKey: n?.receiverPublicKey\n  });\n}\n\nfunction ge(e) {\n  const n = e?.type || L;\n\n  if (n === O) {\n    if (typeof e?.senderPublicKey > \"u\") throw new Error(\"missing sender public key\");\n    if (typeof e?.receiverPublicKey > \"u\") throw new Error(\"missing receiver public key\");\n  }\n\n  return {\n    type: n,\n    senderPublicKey: e?.senderPublicKey,\n    receiverPublicKey: e?.receiverPublicKey\n  };\n}\n\nfunction Nn(e) {\n  return e.type === O && typeof e.senderPublicKey == \"string\" && typeof e.receiverPublicKey == \"string\";\n}\n\nvar gn = Object.defineProperty,\n    ve = Object.getOwnPropertySymbols,\n    vn = Object.prototype.hasOwnProperty,\n    bn = Object.prototype.propertyIsEnumerable,\n    be = (e, n, t) => n in e ? gn(e, n, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: t\n}) : e[n] = t,\n    Oe = (e, n) => {\n  for (var t in n || (n = {})) vn.call(n, t) && be(e, t, n[t]);\n\n  if (ve) for (var t of ve(n)) bn.call(n, t) && be(e, t, n[t]);\n  return e;\n};\n\nconst Se = \"ReactNative\",\n      S = {\n  reactNative: \"react-native\",\n  node: \"node\",\n  browser: \"browser\",\n  unknown: \"unknown\"\n},\n      w = \" \",\n      On = \":\",\n      Ie = \"/\",\n      G = 2,\n      Sn = 1e3,\n      Pe = \"js\";\n\nfunction B() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\n\nfunction Te() {\n  return !en() && !!ae() && navigator.product === Se;\n}\n\nfunction _e() {\n  return !B() && !!ae();\n}\n\nfunction z() {\n  return Te() ? S.reactNative : B() ? S.node : _e() ? S.browser : S.unknown;\n}\n\nfunction Ue(e, n) {\n  let t = U.parse(e);\n  return t = Oe(Oe({}, t), n), e = U.stringify(t), e;\n}\n\nfunction In() {\n  return nn() || {\n    name: \"\",\n    description: \"\",\n    url: \"\",\n    icons: [\"\"]\n  };\n}\n\nfunction Pn(e, n) {\n  var t;\n  const r = z(),\n        o = {\n    protocol: e,\n    version: n,\n    env: r\n  };\n  return r === \"browser\" && (o.host = ((t = ue()) == null ? void 0 : t.host) || \"unknown\"), o;\n}\n\nfunction Ae() {\n  const e = Ze();\n  if (e === null) return \"unknown\";\n  const n = e.os ? e.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return e.type === \"browser\" ? [n, e.name, e.version].join(\"-\") : [n, e.version].join(\"-\");\n}\n\nfunction Re() {\n  var e;\n  const n = z();\n  return n === S.browser ? [n, ((e = ue()) == null ? void 0 : e.host) || \"unknown\"].join(\":\") : n;\n}\n\nfunction Ce(e, n, t) {\n  const r = Ae(),\n        o = Re();\n  return [[e, n].join(\"-\"), [Pe, t].join(\"-\"), r, o].join(\"/\");\n}\n\nfunction Tn(_ref) {\n  let {\n    protocol: e,\n    version: n,\n    relayUrl: t,\n    sdkVersion: r,\n    auth: o,\n    projectId: i\n  } = _ref;\n  const s = t.split(\"?\"),\n        c = Ce(e, n, r),\n        l = {\n    auth: o,\n    ua: c,\n    projectId: i\n  },\n        h = Ue(s[1] || \"\", l);\n  return s[0] + \"?\" + h;\n}\n\nfunction _n(e) {\n  let n = (e.match(/^[^:]+(?=:\\/\\/)/gi) || [])[0];\n  const t = typeof n < \"u\" ? e.split(\"://\")[1] : e;\n  return n = n === \"wss\" ? \"https\" : \"http\", [n, t].join(\"://\");\n}\n\nfunction Un(e, n, t) {\n  if (!e[n] || typeof e[n] !== t) throw new Error(`Missing or invalid \"${n}\" param`);\n}\n\nfunction we(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : G;\n  return De(e.split(Ie), n);\n}\n\nfunction An(e) {\n  return we(e).join(w);\n}\n\nfunction u(e, n) {\n  return e.filter(t => n.includes(t)).length === e.length;\n}\n\nfunction De(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : G;\n  return e.slice(Math.max(e.length - n, 0));\n}\n\nfunction Rn(e) {\n  return Object.fromEntries(e.entries());\n}\n\nfunction Cn(e) {\n  return new Map(Object.entries(e));\n}\n\nfunction wn(e, n) {\n  const t = {};\n  return Object.keys(e).forEach(r => {\n    t[r] = n(e[r]);\n  }), t;\n}\n\nconst Dn = e => e;\n\nfunction $e(e) {\n  return e.trim().replace(/^\\w/, n => n.toUpperCase());\n}\n\nfunction $n(e) {\n  return e.split(w).map(n => $e(n)).join(w);\n}\n\nfunction jn(e, n) {\n  return ce((n || Date.now()) + V(e));\n}\n\nfunction xn(e) {\n  return ce(Date.now()) >= V(e);\n}\n\nfunction Vn() {\n  const e = V(Xe);\n  let n, t, r;\n  return {\n    resolve: o => {\n      r && n && (clearTimeout(r), n(o));\n    },\n    reject: o => {\n      r && t && (clearTimeout(r), t(o));\n    },\n    done: () => new Promise((o, i) => {\n      r = setTimeout(i, e), n = o, t = i;\n    })\n  };\n}\n\nfunction Y(e, n) {\n  if (typeof n == \"string\" && n.startsWith(`${e}:`)) return n;\n\n  if (e.toLowerCase() === \"topic\") {\n    if (typeof n != \"string\") throw new Error('Value must be \"string\" for expirer target type: topic');\n    return `topic:${n}`;\n  } else if (e.toLowerCase() === \"id\") {\n    if (typeof n != \"number\") throw new Error('Value must be \"number\" for expirer target type: id');\n    return `id:${n}`;\n  }\n\n  throw new Error(`Unknown expirer target type: ${e}`);\n}\n\nfunction Mn(e) {\n  return Y(\"topic\", e);\n}\n\nfunction Kn(e) {\n  return Y(\"id\", e);\n}\n\nfunction kn(e) {\n  const [n, t] = e.split(\":\"),\n        r = {\n    id: void 0,\n    topic: void 0\n  };\n  if (n === \"topic\" && typeof t == \"string\") r.topic = t;else if (n === \"id\" && Number.isInteger(Number(t))) r.id = Number(t);else throw new Error(`Invalid target, expected id:number or topic:string, got ${n}:${t}`);\n  return r;\n}\n\nfunction Ln(e, n) {\n  return `${e}${n ? `:${n}` : \"\"}`;\n}\n\nconst je = \"irn\";\n\nfunction Fn(e) {\n  return e?.relay || {\n    protocol: je\n  };\n}\n\nfunction Hn(e) {\n  const n = tn[e];\n  if (typeof n > \"u\") throw new Error(`Relay Protocol not supported: ${e}`);\n  return n;\n}\n\nvar qn = Object.defineProperty,\n    xe = Object.getOwnPropertySymbols,\n    Gn = Object.prototype.hasOwnProperty,\n    Bn = Object.prototype.propertyIsEnumerable,\n    Ve = (e, n, t) => n in e ? qn(e, n, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: t\n}) : e[n] = t,\n    zn = (e, n) => {\n  for (var t in n || (n = {})) Gn.call(n, t) && Ve(e, t, n[t]);\n\n  if (xe) for (var t of xe(n)) Bn.call(n, t) && Ve(e, t, n[t]);\n  return e;\n};\n\nfunction Me(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"-\";\n  const t = {},\n        r = \"relay\" + n;\n  return Object.keys(e).forEach(o => {\n    if (o.startsWith(r)) {\n      const i = o.replace(r, \"\"),\n            s = e[o];\n      t[i] = s;\n    }\n  }), t;\n}\n\nfunction Yn(e) {\n  const n = e.indexOf(\":\"),\n        t = e.indexOf(\"?\") !== -1 ? e.indexOf(\"?\") : void 0,\n        r = e.substring(0, n),\n        o = e.substring(n + 1, t).split(\"@\"),\n        i = typeof t < \"u\" ? e.substring(t) : \"\",\n        s = U.parse(i);\n  return {\n    protocol: r,\n    topic: o[0],\n    version: parseInt(o[1], 10),\n    symKey: s.symKey,\n    relay: Me(s)\n  };\n}\n\nfunction Ke(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"-\";\n  const t = \"relay\",\n        r = {};\n  return Object.keys(e).forEach(o => {\n    const i = t + n + o;\n    e[o] && (r[i] = e[o]);\n  }), r;\n}\n\nfunction Jn(e) {\n  return `${e.protocol}:${e.topic}@${e.version}?` + U.stringify(zn({\n    symKey: e.symKey\n  }, Ke(e.relay)));\n}\n\nfunction m(e) {\n  const n = [];\n  return e.forEach(t => {\n    const [r, o] = t.split(\":\");\n    n.push(`${r}:${o}`);\n  }), n;\n}\n\nfunction ke(e) {\n  const n = [];\n  return Object.values(e).forEach(t => {\n    n.push(...m(t.accounts)), t.extension && t.extension.forEach(r => {\n      n.push(...m(r.accounts));\n    });\n  }), n;\n}\n\nfunction Le(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    m(r.accounts).includes(n) && t.push(...r.methods), r.extension && r.extension.forEach(o => {\n      m(o.accounts).includes(n) && t.push(...o.methods);\n    });\n  }), t;\n}\n\nfunction Fe(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    m(r.accounts).includes(n) && t.push(...r.events), r.extension && r.extension.forEach(o => {\n      m(o.accounts).includes(n) && t.push(...o.events);\n    });\n  }), t;\n}\n\nconst Wn = {\n  INVALID_METHOD: {\n    message: \"Invalid method.\",\n    code: 1001\n  },\n  INVALID_EVENT: {\n    message: \"Invalid event.\",\n    code: 1002\n  },\n  INVALID_UPDATE_REQUEST: {\n    message: \"Invalid update request.\",\n    code: 1003\n  },\n  INVALID_EXTEND_REQUEST: {\n    message: \"Invalid extend request.\",\n    code: 1004\n  },\n  INVALID_SESSION_SETTLE_REQUEST: {\n    message: \"Invalid session settle request.\",\n    code: 1005\n  },\n  UNAUTHORIZED_METHOD: {\n    message: \"Unauthorized method.\",\n    code: 3001\n  },\n  UNAUTHORIZED_EVENT: {\n    message: \"Unauthorized event.\",\n    code: 3002\n  },\n  UNAUTHORIZED_UPDATE_REQUEST: {\n    message: \"Unauthorized update request.\",\n    code: 3003\n  },\n  UNAUTHORIZED_EXTEND_REQUEST: {\n    message: \"Unauthorized extend request.\",\n    code: 3004\n  },\n  USER_REJECTED: {\n    message: \"User rejected.\",\n    code: 5e3\n  },\n  USER_REJECTED_CHAINS: {\n    message: \"User rejected chains.\",\n    code: 5001\n  },\n  USER_REJECTED_METHODS: {\n    message: \"User rejected methods.\",\n    code: 5002\n  },\n  USER_REJECTED_EVENTS: {\n    message: \"User rejected events.\",\n    code: 5003\n  },\n  UNSUPPORTED_CHAINS: {\n    message: \"Unsupported chains.\",\n    code: 5100\n  },\n  UNSUPPORTED_METHODS: {\n    message: \"Unsupported methods.\",\n    code: 5101\n  },\n  UNSUPPORTED_EVENTS: {\n    message: \"Unsupported events.\",\n    code: 5102\n  },\n  UNSUPPORTED_ACCOUNTS: {\n    message: \"Unsupported accounts.\",\n    code: 5103\n  },\n  UNSUPPORTED_NAMESPACE_KEY: {\n    message: \"Unsupported namespace key.\",\n    code: 5104\n  },\n  USER_DISCONNECTED: {\n    message: \"User disconnected.\",\n    code: 6e3\n  },\n  SESSION_SETTLEMENT_FAILED: {\n    message: \"Session settlement failed.\",\n    code: 7e3\n  }\n},\n      Qn = {\n  NOT_INITIALIZED: {\n    message: \"Not initialized.\",\n    code: 1\n  },\n  NO_MATCHING_KEY: {\n    message: \"No matching key.\",\n    code: 2\n  },\n  RESTORE_WILL_OVERRIDE: {\n    message: \"Restore will override.\",\n    code: 3\n  },\n  RESUBSCRIBED: {\n    message: \"Resubscribed.\",\n    code: 4\n  },\n  MISSING_OR_INVALID: {\n    message: \"Missing or invalid.\",\n    code: 5\n  },\n  EXPIRED: {\n    message: \"Expired.\",\n    code: 6\n  },\n  UNKNOWN_TYPE: {\n    message: \"Unknown type.\",\n    code: 7\n  },\n  MISMATCHED_TOPIC: {\n    message: \"Mismatched topic.\",\n    code: 8\n  },\n  NON_CONFORMING_NAMESPACES: {\n    message: \"Non conforming namespaces.\",\n    code: 9\n  }\n};\n\nfunction y(e, n) {\n  const {\n    message: t,\n    code: r\n  } = Qn[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\n\nfunction N(e, n) {\n  const {\n    message: t,\n    code: r\n  } = Wn[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\n\nfunction I(e, n) {\n  return Array.isArray(e) ? typeof n < \"u\" && e.length ? e.every(n) : !0 : !1;\n}\n\nfunction J(e) {\n  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;\n}\n\nfunction E(e) {\n  return typeof e > \"u\";\n}\n\nfunction d(e, n) {\n  return n && E(e) ? !0 : typeof e == \"string\" && Boolean(e.trim().length);\n}\n\nfunction W(e, n) {\n  return n && E(e) ? !0 : typeof e == \"number\" && !isNaN(e);\n}\n\nfunction Zn(e, n) {\n  const {\n    requiredNamespaces: t\n  } = n,\n        r = Object.keys(e.namespaces),\n        o = Object.keys(t);\n  let i = !0;\n  return u(o, r) ? (r.forEach(s => {\n    const {\n      accounts: c,\n      methods: l,\n      events: h,\n      extension: g\n    } = e.namespaces[s],\n          P = m(c),\n          v = t[s];\n    (!u(v.chains, P) || !u(v.methods, l) || !u(v.events, h)) && (i = !1), i && g && g.forEach(_ => {\n      var b;\n      const {\n        accounts: j,\n        methods: ze,\n        events: Ye\n      } = _,\n            Je = m(j);\n      (b = v.extension) != null && b.find(x => u(x.chains, Je) && u(x.methods, ze) && u(x.events, Ye)) || (i = !1);\n    });\n  }), i) : !1;\n}\n\nfunction D(e) {\n  return d(e, !1) && e.includes(\":\") ? e.split(\":\").length === 2 : !1;\n}\n\nfunction He(e) {\n  if (d(e, !1) && e.includes(\":\")) {\n    const n = e.split(\":\");\n\n    if (n.length === 3) {\n      const t = n[0] + \":\" + n[1];\n      return !!n[2] && D(t);\n    }\n  }\n\n  return !1;\n}\n\nfunction Xn(e) {\n  if (d(e, !1)) try {\n    return typeof new URL(e) < \"u\";\n  } catch {\n    return !1;\n  }\n  return !1;\n}\n\nfunction et(e) {\n  var n;\n  return (n = e?.proposer) == null ? void 0 : n.publicKey;\n}\n\nfunction nt(e) {\n  return e?.topic;\n}\n\nfunction tt(e, n) {\n  let t = null;\n  return d(e?.publicKey, !1) || (t = y(\"MISSING_OR_INVALID\", `${n} controller public key should be a string`)), t;\n}\n\nfunction $(e, n) {\n  let t = null;\n  return E(e?.extension) || (!I(e.extension) || !e.extension.length) && (t = y(\"MISSING_OR_INVALID\", `${n} extension should be an array of namespaces, or omitted`)), t;\n}\n\nfunction Q(e) {\n  let n = !0;\n  return I(e) ? e.length && (n = e.every(t => d(t, !1))) : n = !1, n;\n}\n\nfunction Z(e, n, t) {\n  let r = null;\n  return I(n) ? n.forEach(o => {\n    r || (!D(o) || !o.includes(e)) && (r = N(\"UNSUPPORTED_CHAINS\", `${t}, chain ${o} should be a string and conform to \"namespace:chainId\" format`));\n  }) : r = N(\"UNSUPPORTED_CHAINS\", `${t}, chains ${n} should be an array of strings conforming to \"namespace:chainId\" format`), r;\n}\n\nfunction qe(e, n) {\n  let t = null;\n  return Object.entries(e).forEach(_ref2 => {\n    let [r, o] = _ref2;\n    if (t) return;\n    const i = Z(r, o?.chains, `${n} requiredNamespace`),\n          s = $(o, n);\n    i ? t = i : s ? t = s : o.extension && o.extension.forEach(c => {\n      if (t) return;\n      const l = Z(r, c.chains, `${n} extension`);\n      l && (t = l);\n    });\n  }), t;\n}\n\nfunction X(e, n) {\n  let t = null;\n  return I(e) ? e.forEach(r => {\n    t || He(r) || (t = N(\"UNSUPPORTED_ACCOUNTS\", `${n}, account ${r} should be a string and conform to \"namespace:chainId:address\" format`));\n  }) : t = N(\"UNSUPPORTED_ACCOUNTS\", `${n}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`), t;\n}\n\nfunction Ge(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = X(r?.accounts, `${n} namespace`),\n          i = $(r, n);\n    o ? t = o : i ? t = i : r.extension && r.extension.forEach(s => {\n      if (t) return;\n      const c = X(s.accounts, `${n} extension`);\n      c && (t = c);\n    });\n  }), t;\n}\n\nfunction ee(e, n) {\n  let t = null;\n  return Q(e?.methods) ? Q(e?.events) || (t = N(\"UNSUPPORTED_EVENTS\", `${n}, events should be an array of strings or empty array for no events`)) : t = N(\"UNSUPPORTED_METHODS\", `${n}, methods should be an array of strings or empty array for no methods`), t;\n}\n\nfunction ne(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = ee(r, `${n}, namespace`),\n          i = $(r, n);\n    o ? t = o : i ? t = i : r.extension && r.extension.forEach(s => {\n      if (t) return;\n      const c = ee(s, `${n}, extension`);\n      c && (t = c);\n    });\n  }), t;\n}\n\nfunction rt(e, n) {\n  let t = null;\n\n  if (e && J(e)) {\n    const r = ne(e, n);\n    r && (t = r);\n    const o = qe(e, n);\n    o && (t = o);\n  } else t = y(\"MISSING_OR_INVALID\", `${n}, requiredNamespaces should be an object with data`);\n\n  return t;\n}\n\nfunction ot(e, n) {\n  let t = null;\n\n  if (e && J(e)) {\n    const r = ne(e, n);\n    r && (t = r);\n    const o = Ge(e, n);\n    o && (t = o);\n  } else t = y(\"MISSING_OR_INVALID\", `${n}, namespaces should be an object with data`);\n\n  return t;\n}\n\nfunction Be(e) {\n  return d(e.protocol, !0);\n}\n\nfunction st(e, n) {\n  let t = !1;\n  return n && !e ? t = !0 : e && I(e) && e.length && e.forEach(r => {\n    t = Be(r);\n  }), t;\n}\n\nfunction it(e) {\n  return typeof e == \"number\";\n}\n\nfunction ct(e) {\n  return typeof e < \"u\" && typeof e !== null;\n}\n\nfunction at(e) {\n  return !(!e || typeof e != \"object\" || !e.code || !W(e.code, !1) || !e.message || !d(e.message, !1));\n}\n\nfunction ut(e) {\n  return !(E(e) || !d(e.method, !1));\n}\n\nfunction dt(e) {\n  return !(E(e) || E(e.result) && E(e.error) || !W(e.id, !1) || !d(e.jsonrpc, !1));\n}\n\nfunction lt(e) {\n  return !(E(e) || !d(e.name, !1));\n}\n\nfunction ft(e, n) {\n  return !(!D(n) || !ke(e).includes(n));\n}\n\nfunction pt(e, n, t) {\n  return d(t, !1) ? Le(e, n).includes(t) : !1;\n}\n\nfunction mt(e, n, t) {\n  return d(t, !1) ? Fe(e, n).includes(t) : !1;\n}\n\nfunction yt(e, n, t) {\n  let r = null;\n  const o = Object.keys(e),\n        i = Object.keys(n);\n  return u(o, i) ? o.forEach(s => {\n    var c;\n    if (r) return;\n    const l = e[s].chains,\n          h = m(n[s].accounts);\n    u(l, h) ? u(e[s].methods, n[s].methods) ? u(e[s].events, n[s].events) ? e[s].extension && !n[s].extension ? r = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces extension doesn't satisfy requiredNamespaces extension for ${s}`) : e[s].extension && n[s].extension && ((c = e[s].extension) == null || c.forEach(_ref3 => {\n      let {\n        methods: g,\n        events: P,\n        chains: v\n      } = _ref3;\n\n      var _;\n\n      r || (_ = n[s].extension) != null && _.find(b => {\n        const j = m(b.accounts);\n        return u(v, j) && u(P, b.events) && u(g, b.methods);\n      }) || (r = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces extension doesn't satisfy requiredNamespaces extension for ${s}`));\n    })) : r = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces events don't satisfy requiredNamespaces events for ${s}`) : r = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces methods don't satisfy requiredNamespaces methods for ${s}`) : r = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces accounts don't satisfy requiredNamespaces chains for ${s}`);\n  }) : r = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces keys don't satisfy requiredNamespaces`), r;\n}\n\nexport { k as BASE10, a as BASE16, R as BASE64, On as COLON, G as DEFAULT_DEPTH, w as EMPTY_SPACE, S as ENV_MAP, Sn as ONE_THOUSAND, Se as REACT_NATIVE_PRODUCT, je as RELAYER_DEFAULT_PROTOCOL, Pe as SDK_TYPE, Ie as SLASH, L as TYPE_0, O as TYPE_1, C as UTF8, Ue as appendToQueryString, Un as assertType, jn as calcExpiry, $n as capitalize, $e as capitalizeWord, Vn as createDelayedPromise, T as decodeTypeByte, En as decrypt, fn as deriveSymKey, q as deserialize, he as encodeTypeByte, yn as encrypt, Ln as engineEvent, Dn as enumify, fe as formatAccountId, rn as formatAccountWithChain, le as formatChainId, Y as formatExpirerTarget, Kn as formatIdTarget, An as formatMessageContext, Ke as formatRelayParams, Tn as formatRelayRpcUrl, Mn as formatTopicTarget, Ce as formatUA, Jn as formatUri, dn as generateKeyPair, ln as generateRandomBytes32, m as getAccountsChains, sn as getAccountsFromNamespaces, pe as getAddressFromAccount, on as getAddressesFromAccounts, In as getAppMetadata, me as getChainFromAccount, ye as getChainsFromAccounts, cn as getChainsFromNamespaces, an as getChainsFromRequiredNamespaces, z as getEnvironment, _n as getHttpUrl, y as getInternalError, Re as getJavascriptID, Ae as getJavascriptOS, De as getLastItems, ke as getNamespacesChains, Fe as getNamespacesEventsForChainId, Le as getNamespacesMethodsForChainId, Pn as getRelayClientMetadata, Hn as getRelayProtocolApi, Fn as getRelayProtocolName, N as getSdkError, K as getUniqueValues, u as hasOverlap, pn as hashKey, mn as hashMessage, _e as isBrowser, yt as isConformingNamespaces, xn as isExpired, B as isNode, et as isProposalStruct, Te as isReactNative, Zn as isSessionCompatible, nt as isSessionStruct, Nn as isTypeOneEnvelope, E as isUndefined, He as isValidAccountId, X as isValidAccounts, ee as isValidActions, I as isValidArray, D as isValidChainId, Z as isValidChains, tt as isValidController, at as isValidErrorReason, lt as isValidEvent, $ as isValidExtension, it as isValidId, Ge as isValidNamespaceAccounts, ne as isValidNamespaceActions, qe as isValidNamespaceChains, Q as isValidNamespaceMethodsOrEvents, ot as isValidNamespaces, ft as isValidNamespacesChainId, mt as isValidNamespacesEvent, pt as isValidNamespacesRequest, W as isValidNumber, J as isValidObject, ct as isValidParams, Be as isValidRelay, st as isValidRelays, ut as isValidRequest, rt as isValidRequiredNamespaces, dt as isValidResponse, d as isValidString, Xn as isValidUrl, wn as mapEntries, Rn as mapToObj, Cn as objToMap, M as parseAccountId, de as parseChainId, we as parseContextNames, kn as parseExpirerTarget, Me as parseRelayParams, Yn as parseUri, Ne as serialize, hn as validateDecoding, ge as validateEncoding }; //# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module"}