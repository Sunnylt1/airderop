{"ast":null,"code":"import { EventEmitter } from \"events\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { formatJsonRpcError, isReactNative, isWsUrl, isLocalhostUrl, parseConnectionError } from \"@walletconnect/jsonrpc-utils\";\nconst EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;\nconst WS = typeof global.WebSocket !== \"undefined\" ? global.WebSocket : require(\"ws\");\nexport class WsConnection {\n  constructor(url) {\n    this.url = url;\n    this.events = new EventEmitter();\n    this.registering = false;\n\n    if (!isWsUrl(url)) {\n      throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);\n    }\n\n    this.url = url;\n  }\n\n  get connected() {\n    return typeof this.socket !== \"undefined\";\n  }\n\n  get connecting() {\n    return this.registering;\n  }\n\n  on(event, listener) {\n    this.events.on(event, listener);\n  }\n\n  once(event, listener) {\n    this.events.once(event, listener);\n  }\n\n  off(event, listener) {\n    this.events.off(event, listener);\n  }\n\n  removeListener(event, listener) {\n    this.events.removeListener(event, listener);\n  }\n\n  async open() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.url;\n    await this.register(url);\n  }\n\n  async close() {\n    if (typeof this.socket === \"undefined\") {\n      throw new Error(\"Connection already closed\");\n    }\n\n    this.socket.close();\n    this.onClose();\n  }\n\n  async send(payload, context) {\n    if (typeof this.socket === \"undefined\") {\n      this.socket = await this.register();\n    }\n\n    try {\n      this.socket.send(safeJsonStringify(payload));\n    } catch (e) {\n      this.onError(payload.id, e);\n    }\n  }\n\n  register() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.url;\n\n    if (!isWsUrl(url)) {\n      throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);\n    }\n\n    if (this.registering) {\n      const currentMaxListeners = this.events.getMaxListeners();\n\n      if (this.events.listenerCount(\"register_error\") >= currentMaxListeners || this.events.listenerCount(\"open\") >= currentMaxListeners) {\n        this.events.setMaxListeners(currentMaxListeners + 1);\n      }\n\n      return new Promise((resolve, reject) => {\n        this.events.once(\"register_error\", error => {\n          this.resetMaxListeners();\n          reject(error);\n        });\n        this.events.once(\"open\", () => {\n          this.resetMaxListeners();\n\n          if (typeof this.socket === \"undefined\") {\n            return reject(new Error(\"WebSocket connection is missing or invalid\"));\n          }\n\n          resolve(this.socket);\n        });\n      });\n    }\n\n    this.url = url;\n    this.registering = true;\n    return new Promise((resolve, reject) => {\n      const opts = !isReactNative() ? {\n        rejectUnauthorized: !isLocalhostUrl(url)\n      } : undefined;\n      const socket = new WS(url, [], opts);\n\n      socket.onopen = () => {\n        this.onOpen(socket);\n        resolve(socket);\n      };\n\n      socket.onerror = event => {\n        const error = this.parseError(event.error);\n        this.events.emit(\"register_error\", error);\n        this.onClose();\n        reject(error);\n      };\n    });\n  }\n\n  onOpen(socket) {\n    socket.onmessage = event => this.onPayload(event);\n\n    socket.onclose = () => this.onClose();\n\n    socket.onerror = event => {\n      const error = this.parseError(event.error);\n      this.events.emit(\"error\", error);\n    };\n\n    this.socket = socket;\n    this.registering = false;\n    this.events.emit(\"open\");\n  }\n\n  onClose() {\n    this.socket = undefined;\n    this.registering = false;\n    this.events.emit(\"close\");\n  }\n\n  onPayload(e) {\n    if (typeof e.data === \"undefined\") return;\n    const payload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n    this.events.emit(\"payload\", payload);\n  }\n\n  onError(id, e) {\n    const error = this.parseError(e);\n    const message = error.message || error.toString();\n    const payload = formatJsonRpcError(id, message);\n    this.events.emit(\"payload\", payload);\n  }\n\n  parseError(e) {\n    let url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.url;\n    return parseConnectionError(e, url, \"WS\");\n  }\n\n  resetMaxListeners() {\n    if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {\n      this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);\n    }\n  }\n\n}\nexport default WsConnection; //# sourceMappingURL=ws.js.map","map":null,"metadata":{},"sourceType":"module"}