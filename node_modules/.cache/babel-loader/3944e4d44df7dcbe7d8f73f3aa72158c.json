{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bufferXOR = exports.setDifference = exports.arrayContains = exports.arraysEqual = exports.hasPrefix = exports.isURType = exports.intToBytes = exports.toUint32 = exports.getCRCHex = exports.getCRC = exports.split = exports.partition = exports.sha256Hash = void 0;\n\nconst sha_js_1 = __importDefault(require(\"sha.js\"));\n\nconst crc_1 = require(\"crc\");\n\nconst sha256Hash = data => sha_js_1.default('sha256').update(data).digest();\n\nexports.sha256Hash = sha256Hash;\n\nconst partition = (s, n) => s.match(new RegExp('.{1,' + n + '}', 'g')) || [s];\n\nexports.partition = partition;\n\nconst split = (s, length) => [s.slice(0, -length), s.slice(-length)];\n\nexports.split = split;\n\nconst getCRC = message => crc_1.crc32(message);\n\nexports.getCRC = getCRC;\n\nconst getCRCHex = message => crc_1.crc32(message).toString(16).padStart(8, '0');\n\nexports.getCRCHex = getCRCHex;\n\nconst toUint32 = number => number >>> 0;\n\nexports.toUint32 = toUint32;\n\nconst intToBytes = num => {\n  const arr = new ArrayBuffer(4); // an Int32 takes 4 bytes\n\n  const view = new DataView(arr);\n  view.setUint32(0, num, false); // byteOffset = 0; litteEndian = false\n\n  return Buffer.from(arr);\n};\n\nexports.intToBytes = intToBytes;\n\nconst isURType = type => {\n  return type.split('').every((_, index) => {\n    let c = type.charCodeAt(index);\n    if ('a'.charCodeAt(0) <= c && c <= 'z'.charCodeAt(0)) return true;\n    if ('0'.charCodeAt(0) <= c && c <= '9'.charCodeAt(0)) return true;\n    if (c === '-'.charCodeAt(0)) return true;\n    return false;\n  });\n};\n\nexports.isURType = isURType;\n\nconst hasPrefix = (s, prefix) => s.indexOf(prefix) === 0;\n\nexports.hasPrefix = hasPrefix;\n\nconst arraysEqual = (ar1, ar2) => {\n  if (ar1.length !== ar2.length) {\n    return false;\n  }\n\n  return ar1.every(el => ar2.includes(el));\n};\n\nexports.arraysEqual = arraysEqual;\n/**\n * Checks if ar1 contains all elements of ar2\n * @param ar1 the outer array\n * @param ar2 the array to be contained in ar1\n */\n\nconst arrayContains = (ar1, ar2) => {\n  return ar2.every(v => ar1.includes(v));\n};\n\nexports.arrayContains = arrayContains;\n/**\n * Returns the difference array of  `ar1` - `ar2`\n */\n\nconst setDifference = (ar1, ar2) => {\n  return ar1.filter(x => ar2.indexOf(x) < 0);\n};\n\nexports.setDifference = setDifference;\n\nconst bufferXOR = (a, b) => {\n  const length = Math.max(a.length, b.length);\n  const buffer = Buffer.allocUnsafe(length);\n\n  for (let i = 0; i < length; ++i) {\n    buffer[i] = a[i] ^ b[i];\n  }\n\n  return buffer;\n};\n\nexports.bufferXOR = bufferXOR; //# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"script"}