{"ast":null,"code":"/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\nimport { crypto } from '@noble/hashes/crypto'; // Cast array to different type\n\nexport const u8 = arr => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = arr => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4)); // Cast array to view\n\nexport const createView = arr => new DataView(arr.buffer, arr.byteOffset, arr.byteLength); // The rotate right (circular right shift) operation for uint32\n\nexport const rotr = (word, shift) => word << 32 - shift | word >>> shift;\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44; // There is almost no big endian hardware, but js typed arrays uses platform specific endianness.\n// So, just to be sure not to corrupt anything.\n\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */\n\nexport function bytesToHex(uint8a) {\n  // pre-caching improves the speed 6x\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');\n  let hex = '';\n\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n\n  return hex;\n}\n/**\n * @example hexToBytes('deadbeef')\n */\n\nexport function hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');\n  const array = new Uint8Array(hex.length / 2);\n\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n\n  return array;\n} // There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise\n// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.\n\nexport const nextTick = async () => {}; // Returns control to thread each 'tick' ms to avoid blocking\n\nexport async function asyncLoop(iters, tick, cb) {\n  let ts = Date.now();\n\n  for (let i = 0; i < iters; i++) {\n    cb(i); // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\nexport function utf8ToBytes(str) {\n  if (typeof str !== 'string') {\n    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n  }\n\n  return new TextEncoder().encode(str);\n}\nexport function toBytes(data) {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!(data instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n  return data;\n}\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\n\nexport function concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n\n  if (!arrays.every(a => a instanceof Uint8Array)) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n\n  return result;\n} // For runtime check if class implements interface\n\nexport class Hash {\n  // Safe version that clones internal state\n  clone() {\n    return this._cloneInto();\n  }\n\n} // Check if object doens't have custom constructor (like Uint8Array/Array)\n\nconst isPlainObject = obj => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\n\nexport function checkOpts(defaults, opts) {\n  if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts))) throw new TypeError('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged;\n}\nexport function wrapConstructor(hashConstructor) {\n  const hashC = message => hashConstructor().update(toBytes(message)).digest();\n\n  const tmp = hashConstructor();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n\n  hashC.create = () => hashConstructor();\n\n  return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n\n  const tmp = hashCons({});\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n\n  hashC.create = opts => hashCons(opts);\n\n  return hashC;\n}\n/**\n * Secure PRNG\n */\n\nexport function randomBytes() {\n  let bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n\n  if (crypto.web) {\n    return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n  } else if (crypto.node) {\n    return new Uint8Array(crypto.node.randomBytes(bytesLength).buffer);\n  } else {\n    throw new Error(\"The environment doesn't have randomBytes function\");\n  }\n}","map":null,"metadata":{},"sourceType":"module"}