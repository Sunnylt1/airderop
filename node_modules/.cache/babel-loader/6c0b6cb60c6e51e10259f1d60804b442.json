{"ast":null,"code":"import { WalletNotConnectedError, WalletNotReadyError, WalletReadyState } from '@solana/wallet-adapter-base';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { WalletNotSelectedError } from './errors.js';\nimport { useLocalStorage } from './useLocalStorage.js';\nimport { WalletContext } from './useWallet.js';\nconst initialState = {\n  wallet: null,\n  adapter: null,\n  publicKey: null,\n  connected: false\n};\nexport const WalletProvider = _ref => {\n  let {\n    children,\n    wallets: adapters,\n    autoConnect = false,\n    onError,\n    localStorageKey = 'walletName'\n  } = _ref;\n  const [name, setName] = useLocalStorage(localStorageKey, null);\n  const [{\n    wallet,\n    adapter,\n    publicKey,\n    connected\n  }, setState] = useState(initialState);\n  const readyState = adapter?.readyState || WalletReadyState.Unsupported;\n  const [connecting, setConnecting] = useState(false);\n  const [disconnecting, setDisconnecting] = useState(false);\n  const isConnecting = useRef(false);\n  const isDisconnecting = useRef(false);\n  const isUnloading = useRef(false); // Wrap adapters to conform to the `Wallet` interface\n\n  const [wallets, setWallets] = useState(() => adapters.map(adapter => ({\n    adapter,\n    readyState: adapter.readyState\n  }))); // When the adapters change, start to listen for changes to their `readyState`\n\n  useEffect(() => {\n    // When the adapters change, wrap them to conform to the `Wallet` interface\n    setWallets(wallets => adapters.map((adapter, index) => {\n      const wallet = wallets[index]; // If the wallet hasn't changed, return the same instance\n\n      return wallet && wallet.adapter === adapter && wallet.readyState === adapter.readyState ? wallet : {\n        adapter: adapter,\n        readyState: adapter.readyState\n      };\n    }));\n\n    function handleReadyStateChange(readyState) {\n      setWallets(prevWallets => {\n        const index = prevWallets.findIndex(_ref2 => {\n          let {\n            adapter\n          } = _ref2;\n          return adapter === this;\n        });\n        if (index === -1) return prevWallets; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        const {\n          adapter\n        } = prevWallets[index];\n        return [...prevWallets.slice(0, index), {\n          adapter,\n          readyState\n        }, ...prevWallets.slice(index + 1)];\n      });\n    }\n\n    adapters.forEach(adapter => adapter.on('readyStateChange', handleReadyStateChange, adapter));\n    return () => adapters.forEach(adapter => adapter.off('readyStateChange', handleReadyStateChange, adapter));\n  }, [adapters]); // When the selected wallet changes, initialize the state\n\n  useEffect(() => {\n    const wallet = name && wallets.find(_ref3 => {\n      let {\n        adapter\n      } = _ref3;\n      return adapter.name === name;\n    });\n\n    if (wallet) {\n      setState({\n        wallet,\n        adapter: wallet.adapter,\n        connected: wallet.adapter.connected,\n        publicKey: wallet.adapter.publicKey\n      });\n    } else {\n      setState(initialState);\n    }\n  }, [name, wallets]); // If the window is closing or reloading, ignore disconnect and error events from the adapter\n\n  useEffect(() => {\n    function listener() {\n      isUnloading.current = true;\n    }\n\n    window.addEventListener('beforeunload', listener);\n    return () => window.removeEventListener('beforeunload', listener);\n  }, [isUnloading]); // Handle the adapter's connect event\n\n  const handleConnect = useCallback(() => {\n    if (!adapter) return;\n    setState(state => ({ ...state,\n      connected: adapter.connected,\n      publicKey: adapter.publicKey\n    }));\n  }, [adapter]); // Handle the adapter's disconnect event\n\n  const handleDisconnect = useCallback(() => {\n    // Clear the selected wallet unless the window is unloading\n    if (!isUnloading.current) setName(null);\n  }, [isUnloading, setName]); // Handle the adapter's error event, and local errors\n\n  const handleError = useCallback(error => {\n    // Call onError unless the window is unloading\n    if (!isUnloading.current) (onError || console.error)(error);\n    return error;\n  }, [isUnloading, onError]); // Setup and teardown event listeners when the adapter changes\n\n  useEffect(() => {\n    if (adapter) {\n      adapter.on('connect', handleConnect);\n      adapter.on('disconnect', handleDisconnect);\n      adapter.on('error', handleError);\n      return () => {\n        adapter.off('connect', handleConnect);\n        adapter.off('disconnect', handleDisconnect);\n        adapter.off('error', handleError);\n      };\n    }\n  }, [adapter, handleConnect, handleDisconnect, handleError]); // When the adapter changes, disconnect the old one\n\n  useEffect(() => {\n    return () => {\n      adapter?.disconnect();\n    };\n  }, [adapter]); // If autoConnect is enabled, try to connect when the adapter changes and is ready\n\n  useEffect(() => {\n    if (isConnecting.current || connected || !autoConnect || !adapter || !(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable)) return;\n\n    (async function () {\n      isConnecting.current = true;\n      setConnecting(true);\n\n      try {\n        await adapter.connect();\n      } catch (error) {\n        // Clear the selected wallet\n        setName(null); // Don't throw error, but handleError will still be called\n      } finally {\n        setConnecting(false);\n        isConnecting.current = false;\n      }\n    })();\n  }, [isConnecting, connected, autoConnect, adapter, readyState, setName]); // Connect the adapter to the wallet\n\n  const connect = useCallback(async () => {\n    if (isConnecting.current || isDisconnecting.current || connected) return;\n    if (!adapter) throw handleError(new WalletNotSelectedError());\n\n    if (!(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable)) {\n      // Clear the selected wallet\n      setName(null);\n\n      if (typeof window !== 'undefined') {\n        window.open(adapter.url, '_blank');\n      }\n\n      throw handleError(new WalletNotReadyError());\n    }\n\n    isConnecting.current = true;\n    setConnecting(true);\n\n    try {\n      await adapter.connect();\n    } catch (error) {\n      // Clear the selected wallet\n      setName(null); // Rethrow the error, and handleError will also be called\n\n      throw error;\n    } finally {\n      setConnecting(false);\n      isConnecting.current = false;\n    }\n  }, [isConnecting, isDisconnecting, connected, adapter, readyState, handleError, setName]); // Disconnect the adapter from the wallet\n\n  const disconnect = useCallback(async () => {\n    if (isDisconnecting.current) return;\n    if (!adapter) return setName(null);\n    isDisconnecting.current = true;\n    setDisconnecting(true);\n\n    try {\n      await adapter.disconnect();\n    } catch (error) {\n      // Clear the selected wallet\n      setName(null); // Rethrow the error, and handleError will also be called\n\n      throw error;\n    } finally {\n      setDisconnecting(false);\n      isDisconnecting.current = false;\n    }\n  }, [isDisconnecting, adapter, setName]); // Send a transaction using the provided connection\n\n  const sendTransaction = useCallback(async (transaction, connection, options) => {\n    if (!adapter) throw handleError(new WalletNotSelectedError());\n    if (!connected) throw handleError(new WalletNotConnectedError());\n    return await adapter.sendTransaction(transaction, connection, options);\n  }, [adapter, handleError, connected]); // Sign a transaction if the wallet supports it\n\n  const signTransaction = useMemo(() => adapter && 'signTransaction' in adapter ? async transaction => {\n    if (!connected) throw handleError(new WalletNotConnectedError());\n    return await adapter.signTransaction(transaction);\n  } : undefined, [adapter, handleError, connected]); // Sign multiple transactions if the wallet supports it\n\n  const signAllTransactions = useMemo(() => adapter && 'signAllTransactions' in adapter ? async transactions => {\n    if (!connected) throw handleError(new WalletNotConnectedError());\n    return await adapter.signAllTransactions(transactions);\n  } : undefined, [adapter, handleError, connected]); // Sign an arbitrary message if the wallet supports it\n\n  const signMessage = useMemo(() => adapter && 'signMessage' in adapter ? async message => {\n    if (!connected) throw handleError(new WalletNotConnectedError());\n    return await adapter.signMessage(message);\n  } : undefined, [adapter, handleError, connected]);\n  return React.createElement(WalletContext.Provider, {\n    value: {\n      autoConnect,\n      wallets,\n      wallet,\n      publicKey,\n      connected,\n      connecting,\n      disconnecting,\n      select: setName,\n      connect,\n      disconnect,\n      sendTransaction,\n      signTransaction,\n      signAllTransactions,\n      signMessage\n    }\n  }, children);\n}; //# sourceMappingURL=WalletProvider.js.map","map":null,"metadata":{},"sourceType":"module"}